{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Edgartools Documentation edgartools is a Python library for navigating SEC filings. Getting Started 1. Install pip install edgartools There are frequent releases so it is a good idea to use pip install -U edgartools to get new features and bug fixes. That being said we try to keep the API stable and backwards compatible. If you prefer uv instead of pip you can use the following command: uv pip install edgartools 2. Import edgar The main way to use the library is to import everything with from edgar import * . This will give you access to most of the functions and classes you need. from edgar import * If you prefer a minimal import you can use the following: 3. Set your identity Before you can access the SEC Edgar API you need to set the identity that you will use to access Edgar. This is usually your name and email , but you can also just use an email. You can set your identity in Python before you start using the library. Setting your identity in Python from edgar import * set_identity(\"mike.mccalum@indigo.com\") Setting your identity using an environment variable You can also set your identity using an environment variable. This is useful if you are using the library in a script or notebook. export EDGAR_IDENTITY=\"mike.mccalum@indigo.com\" Usage Getting Filings The library is designed to be easy to use and flexible. You can start by getting all filings for the current year and quarter with get_filings() . filings = get_filings() You can expand beyond the current year and quarter by using the parameters of the get_filings function. For example you can specify the year you want to get filings for: filings = get_filings(year=2021) For more details on filtering filings see the Filtering Filings docs Selecting a filing You can select a filing using the [] operator. For example to get the third filing in the list: filing = filings[3] Paginating filings The Filings object is a container for a list of filings. The list of filings can be large but by default you can only see the first page of filings. To change the page, you can paginate filings using the next and prev methods. For example: filings = get_filings() filings.next() filings.previous() Looping through filings You can loop through filings using the for loop. For example: filings = get_filings() for filing in filings: # Do something with the filing Getting Related Filings Filings can be related to other filings using the file number. In some cases this relationship can be meaningful, as in they represent a group of filings for a specific securities offering. The link between the filing is via the file_number attribute of the filing, which is an identifier that the SEC uses to group filings. You can get related filings using the get_related_filings method. For example: filing = get_filing('0000320193-22-000002') filings = filing.related_filings() Getting a Company You can start by getting a company by CIK or Ticker with Company() . For example: c = Company(\"AAPL\") filings = c.filings You can also get a company by CIK. For example: c = Company(\"0000320193\") filings = c.filings To get a Company by ticker, the library first does a lookup of the CIK for the ticker and then gets filings for the CIK. So if you know the CIK, it is faster to use that directly. Company Filings You can get the filings for a company by using the filings property. For example: filings = c.filings This property returns a Filings object that you can use to filter and manipulate the filings. Initially the filings property lists around 1000 filings for the company that were returned from the API call to the SEC. Normally this is OK since these are the 1000 most recent filings. However, some companies have more than 1000 filings, and you might need to get older filings. To trigger the retrieval of older filings you can use the get_filings() method. For example: filings = c.get_filings() Getting Company Facts You can get facts for a company using the get_facts() method. For example: facts = c.get_facts() The result is an EntityFacts object that wraps the data returned from the SEC API. To get the data as a dataframe use the to_pandas() method. For example: facts_df = facts.to_pandas() Getting Company Financials You can get financials for a company using the financials property. For example: financials = c.financials financials.income Viewing unpublished filings The SEC publishes the filing indexes week nights by 10:30 PM EST. To get the latest filings not yet in the index use the get_latest_filings function. For example: filings = get_latest_filings()","title":"Overview"},{"location":"#edgartools-documentation","text":"edgartools is a Python library for navigating SEC filings.","title":"Edgartools Documentation"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#1-install","text":"pip install edgartools There are frequent releases so it is a good idea to use pip install -U edgartools to get new features and bug fixes. That being said we try to keep the API stable and backwards compatible. If you prefer uv instead of pip you can use the following command: uv pip install edgartools","title":"1. Install"},{"location":"#2-import-edgar","text":"The main way to use the library is to import everything with from edgar import * . This will give you access to most of the functions and classes you need. from edgar import * If you prefer a minimal import you can use the following:","title":"2. Import edgar"},{"location":"#3-set-your-identity","text":"Before you can access the SEC Edgar API you need to set the identity that you will use to access Edgar. This is usually your name and email , but you can also just use an email. You can set your identity in Python before you start using the library.","title":"3. Set your identity"},{"location":"#setting-your-identity-in-python","text":"from edgar import * set_identity(\"mike.mccalum@indigo.com\")","title":"Setting your identity in Python"},{"location":"#setting-your-identity-using-an-environment-variable","text":"You can also set your identity using an environment variable. This is useful if you are using the library in a script or notebook. export EDGAR_IDENTITY=\"mike.mccalum@indigo.com\"","title":"Setting your identity using an environment variable"},{"location":"#usage","text":"","title":"Usage"},{"location":"#getting-filings","text":"The library is designed to be easy to use and flexible. You can start by getting all filings for the current year and quarter with get_filings() . filings = get_filings() You can expand beyond the current year and quarter by using the parameters of the get_filings function. For example you can specify the year you want to get filings for: filings = get_filings(year=2021) For more details on filtering filings see the Filtering Filings docs","title":"Getting Filings"},{"location":"#selecting-a-filing","text":"You can select a filing using the [] operator. For example to get the third filing in the list: filing = filings[3]","title":"Selecting a filing"},{"location":"#paginating-filings","text":"The Filings object is a container for a list of filings. The list of filings can be large but by default you can only see the first page of filings. To change the page, you can paginate filings using the next and prev methods. For example: filings = get_filings() filings.next() filings.previous()","title":"Paginating filings"},{"location":"#looping-through-filings","text":"You can loop through filings using the for loop. For example: filings = get_filings() for filing in filings: # Do something with the filing","title":"Looping through filings"},{"location":"#getting-related-filings","text":"Filings can be related to other filings using the file number. In some cases this relationship can be meaningful, as in they represent a group of filings for a specific securities offering. The link between the filing is via the file_number attribute of the filing, which is an identifier that the SEC uses to group filings. You can get related filings using the get_related_filings method. For example: filing = get_filing('0000320193-22-000002') filings = filing.related_filings()","title":"Getting Related Filings"},{"location":"#getting-a-company","text":"You can start by getting a company by CIK or Ticker with Company() . For example: c = Company(\"AAPL\") filings = c.filings You can also get a company by CIK. For example: c = Company(\"0000320193\") filings = c.filings To get a Company by ticker, the library first does a lookup of the CIK for the ticker and then gets filings for the CIK. So if you know the CIK, it is faster to use that directly.","title":"Getting a Company"},{"location":"#company-filings","text":"You can get the filings for a company by using the filings property. For example: filings = c.filings This property returns a Filings object that you can use to filter and manipulate the filings. Initially the filings property lists around 1000 filings for the company that were returned from the API call to the SEC. Normally this is OK since these are the 1000 most recent filings. However, some companies have more than 1000 filings, and you might need to get older filings. To trigger the retrieval of older filings you can use the get_filings() method. For example: filings = c.get_filings()","title":"Company Filings"},{"location":"#getting-company-facts","text":"You can get facts for a company using the get_facts() method. For example: facts = c.get_facts() The result is an EntityFacts object that wraps the data returned from the SEC API. To get the data as a dataframe use the to_pandas() method. For example: facts_df = facts.to_pandas()","title":"Getting Company Facts"},{"location":"#getting-company-financials","text":"You can get financials for a company using the financials property. For example: financials = c.financials financials.income","title":"Getting Company Financials"},{"location":"#viewing-unpublished-filings","text":"The SEC publishes the filing indexes week nights by 10:30 PM EST. To get the latest filings not yet in the index use the get_latest_filings function. For example: filings = get_latest_filings()","title":"Viewing unpublished filings"},{"location":"BRAINSTORM_FINANCIAL_ANALYSIS/","text":"Brainstorming: Innovative Financial Analysis Adjudication Objective: Replace hardcoded keywords/heuristics in \"Related SEC Findings\" with dynamic, financially sensitive signals. Framework: Think-Pause-Rethink 1. Mental Model: Inversion (The \"Diff\" Engine) Think: \"What are the key words in this filing?\" Rethink: \"What changed in this filing compared to the last one?\" Concept: Instead of scoring the static text, score the delta . - Implementation: - Risk Factor Drift: Calculate Cosine Similarity between the \"Risk Factors\" (Item 1A) of the current 10-K/Q and the previous one. - Signal: Low similarity = High Relevance. It means the company is rewriting its risks (e.g., adding \"AI regulation\" or \"Supply chain disruption\"). - Adjudication: \"Relevance Score\" boosts if similarity < 0.9 . 2. Mental Model: The Map is Not the Territory (Market-Derived Relevance) Think: \"Is this 8-K important based on its form type?\" Rethink: \"Did the market care about this 8-K?\" Concept: Use Price Velocity as the ground truth for relevance, not the text. - Implementation: - Volatility Intersection: Calculate the standard deviation of price returns in the 30 minutes after the filing timestamp. - Signal: If Post-Filing Volatility > 3x Average Volatility , the filing is Critical , regardless of what it says. - Adjudication: Override any text-based score if market reaction is violent. Label: \"Market Mover\". 3. Mental Model: Signal vs. Noise (Linguistic Entropy) Think: \"Does it contain the word 'lawsuit'?\" Rethink: \"Is the language unusually complex or evasive?\" Concept: Obfuscation Detection . - Implementation: - Gunning-Fog Index: Measure the readability complexity. - Hedge Word Density: Count frequency of \"may\", \"could\", \"might\", \"approximately\". - Signal: A sudden spike in complexity or hedge words often hides bad news (e.g., trying to bury a missed earnings target in complex prose). - Adjudication: \"High Complexity Alert\" \u2013 likely hiding negative nuance. 4. Mental Model: Second-Order Thinking (The \"Peer\" Effect) Think: \"How does this affect AAPL?\" Rethink: \"How does this compare to MSFT's filing yesterday?\" Concept: Sector Benchmarking . - Implementation: - Thematic Divergence: If MSFT, GOOGL, and AMZN all mention \"AI CapEx\" in their 10-Qs, but AAPL doesn't , that omission is the signal. - Signal: Divergence from the sector trend. - Adjudication: \"Sector Outlier\". Proposed Architecture: The \"Adjudicator\" Pipeline We can replace the simple scoring.py with a multi-agent \"Adjudicator\": The Quant Agent: Calculates Price Velocity & Volatility around the filing timestamp. The Linguist Agent: Calculates Diff Similarity & Fog Index. The Historian Agent: Checks if this event (e.g., \"CFO Resignation\") historically caused a drop for this specific stock . Example Output in Dashboard Instead of: 8-K: No details \ud83d\udfe1 Possibly related We generate: 8-K: Critical \ud83d\udd34 (Score: 0.95) * Market Reaction: Price dropped 2.4% within 15 mins of filing. * Risk Drift: 40% change in \"Risk Factors\" vs. last quarter. * Context: \"Departure of Directors\" (Historical impact: -1.2%)*","title":"Brainstorming: Innovative Financial Analysis Adjudication"},{"location":"BRAINSTORM_FINANCIAL_ANALYSIS/#brainstorming-innovative-financial-analysis-adjudication","text":"Objective: Replace hardcoded keywords/heuristics in \"Related SEC Findings\" with dynamic, financially sensitive signals.","title":"Brainstorming: Innovative Financial Analysis Adjudication"},{"location":"BRAINSTORM_FINANCIAL_ANALYSIS/#framework-think-pause-rethink","text":"","title":"Framework: Think-Pause-Rethink"},{"location":"BRAINSTORM_FINANCIAL_ANALYSIS/#1-mental-model-inversion-the-diff-engine","text":"Think: \"What are the key words in this filing?\" Rethink: \"What changed in this filing compared to the last one?\" Concept: Instead of scoring the static text, score the delta . - Implementation: - Risk Factor Drift: Calculate Cosine Similarity between the \"Risk Factors\" (Item 1A) of the current 10-K/Q and the previous one. - Signal: Low similarity = High Relevance. It means the company is rewriting its risks (e.g., adding \"AI regulation\" or \"Supply chain disruption\"). - Adjudication: \"Relevance Score\" boosts if similarity < 0.9 .","title":"1. Mental Model: Inversion (The \"Diff\" Engine)"},{"location":"BRAINSTORM_FINANCIAL_ANALYSIS/#2-mental-model-the-map-is-not-the-territory-market-derived-relevance","text":"Think: \"Is this 8-K important based on its form type?\" Rethink: \"Did the market care about this 8-K?\" Concept: Use Price Velocity as the ground truth for relevance, not the text. - Implementation: - Volatility Intersection: Calculate the standard deviation of price returns in the 30 minutes after the filing timestamp. - Signal: If Post-Filing Volatility > 3x Average Volatility , the filing is Critical , regardless of what it says. - Adjudication: Override any text-based score if market reaction is violent. Label: \"Market Mover\".","title":"2. Mental Model: The Map is Not the Territory (Market-Derived Relevance)"},{"location":"BRAINSTORM_FINANCIAL_ANALYSIS/#3-mental-model-signal-vs-noise-linguistic-entropy","text":"Think: \"Does it contain the word 'lawsuit'?\" Rethink: \"Is the language unusually complex or evasive?\" Concept: Obfuscation Detection . - Implementation: - Gunning-Fog Index: Measure the readability complexity. - Hedge Word Density: Count frequency of \"may\", \"could\", \"might\", \"approximately\". - Signal: A sudden spike in complexity or hedge words often hides bad news (e.g., trying to bury a missed earnings target in complex prose). - Adjudication: \"High Complexity Alert\" \u2013 likely hiding negative nuance.","title":"3. Mental Model: Signal vs. Noise (Linguistic Entropy)"},{"location":"BRAINSTORM_FINANCIAL_ANALYSIS/#4-mental-model-second-order-thinking-the-peer-effect","text":"Think: \"How does this affect AAPL?\" Rethink: \"How does this compare to MSFT's filing yesterday?\" Concept: Sector Benchmarking . - Implementation: - Thematic Divergence: If MSFT, GOOGL, and AMZN all mention \"AI CapEx\" in their 10-Qs, but AAPL doesn't , that omission is the signal. - Signal: Divergence from the sector trend. - Adjudication: \"Sector Outlier\".","title":"4. Mental Model: Second-Order Thinking (The \"Peer\" Effect)"},{"location":"BRAINSTORM_FINANCIAL_ANALYSIS/#proposed-architecture-the-adjudicator-pipeline","text":"We can replace the simple scoring.py with a multi-agent \"Adjudicator\": The Quant Agent: Calculates Price Velocity & Volatility around the filing timestamp. The Linguist Agent: Calculates Diff Similarity & Fog Index. The Historian Agent: Checks if this event (e.g., \"CFO Resignation\") historically caused a drop for this specific stock .","title":"Proposed Architecture: The \"Adjudicator\" Pipeline"},{"location":"BRAINSTORM_FINANCIAL_ANALYSIS/#example-output-in-dashboard","text":"Instead of: 8-K: No details \ud83d\udfe1 Possibly related We generate: 8-K: Critical \ud83d\udd34 (Score: 0.95) * Market Reaction: Price dropped 2.4% within 15 mins of filing. * Risk Drift: 40% change in \"Risk Factors\" vs. last quarter. * Context: \"Departure of Directors\" (Historical impact: -1.2%)*","title":"Example Output in Dashboard"},{"location":"DIVERGENCE_LOG/","text":"Divergence Log This file tracks all modifications made to the core edgar/ library code that deviate from the original edgartools v4.0.0 base. 2025-11-30: SEC Filing Enrichment Fixes 1. Fix Date Type Checking in fetch_recent_filings File : edgar/sec_filings.py Change : Updated fetch_recent_filings to handle datetime.date objects returned by the underlying library. Reason : The original code strictly checked for datetime.datetime , causing valid filings to be skipped. Status : Custom fix (Upstream status unknown). 2. Increase Lookback Period for Alerts File : edgar/filing_context_appender.py Change : Increased default days_back from 2 to 90 in enrich_all_alerts_with_filings and safe_enrich_all_alerts . Reason : A 2-day lookback is insufficient for a weekly pipeline; 90 days ensures quarterly (10-Q) and annual (10-K) filings are captured. Status : Custom configuration change. 3. Architectural Refactoring (2025-11-30) Change : Moved custom application logic out of edgar/ and into pipeline/ . Files Moved : edgar/filing_context_appender.py -> pipeline/enrichment.py edgar/filing_scorer.py -> pipeline/scoring.py edgar/filing_summarizer.py -> pipeline/summarizer.py edgar/polygon.py -> pipeline/polygon.py edgar/financial_analyzer.py -> pipeline/financial_analyzer.py edgar/sec_filings.py -> pipeline/sec_filings.py Impact : edgar/ directory now contains only core library code (plus the sec_filings.py fix which is now in pipeline/ but was originally a library file). Note : sec_filings.py was moved to pipeline/ to keep all custom/modified code together, even though it started as a library file. This means edgar/ is now effectively pristine upstream code (minus the missing sec_filings.py ).","title":"Divergence Log"},{"location":"DIVERGENCE_LOG/#divergence-log","text":"This file tracks all modifications made to the core edgar/ library code that deviate from the original edgartools v4.0.0 base.","title":"Divergence Log"},{"location":"DIVERGENCE_LOG/#2025-11-30-sec-filing-enrichment-fixes","text":"","title":"2025-11-30: SEC Filing Enrichment Fixes"},{"location":"DIVERGENCE_LOG/#1-fix-date-type-checking-in-fetch_recent_filings","text":"File : edgar/sec_filings.py Change : Updated fetch_recent_filings to handle datetime.date objects returned by the underlying library. Reason : The original code strictly checked for datetime.datetime , causing valid filings to be skipped. Status : Custom fix (Upstream status unknown).","title":"1. Fix Date Type Checking in fetch_recent_filings"},{"location":"DIVERGENCE_LOG/#2-increase-lookback-period-for-alerts","text":"File : edgar/filing_context_appender.py Change : Increased default days_back from 2 to 90 in enrich_all_alerts_with_filings and safe_enrich_all_alerts . Reason : A 2-day lookback is insufficient for a weekly pipeline; 90 days ensures quarterly (10-Q) and annual (10-K) filings are captured. Status : Custom configuration change.","title":"2. Increase Lookback Period for Alerts"},{"location":"DIVERGENCE_LOG/#3-architectural-refactoring-2025-11-30","text":"Change : Moved custom application logic out of edgar/ and into pipeline/ . Files Moved : edgar/filing_context_appender.py -> pipeline/enrichment.py edgar/filing_scorer.py -> pipeline/scoring.py edgar/filing_summarizer.py -> pipeline/summarizer.py edgar/polygon.py -> pipeline/polygon.py edgar/financial_analyzer.py -> pipeline/financial_analyzer.py edgar/sec_filings.py -> pipeline/sec_filings.py Impact : edgar/ directory now contains only core library code (plus the sec_filings.py fix which is now in pipeline/ but was originally a library file). Note : sec_filings.py was moved to pipeline/ to keep all custom/modified code together, even though it started as a library file. This means edgar/ is now effectively pristine upstream code (minus the missing sec_filings.py ).","title":"3. Architectural Refactoring (2025-11-30)"},{"location":"FINANCIAL_ANALYZER/","text":"Financial Analyzer Module Overview The pipeline.financial_analyzer module extracts historical ROIC (Return on Invested Capital), calculates WACC (Weighted Average Cost of Capital), and computes the spread (ROIC - WACC) for portfolio analysis. It uses XBRL data from SEC 10-K filings with intelligent fallback mechanisms. This module is part of Phase 4 Pillar 1: Financial Data Foundation and provides the core financial metrics needed for valuation and quality assessment. Key Concepts ROIC (Return on Invested Capital) ROIC measures how efficiently a company generates returns from its invested capital: ROIC = NOPAT / Invested Capital Where: - NOPAT = Operating Income \u00d7 (1 - Tax Rate) - Invested Capital = Total Assets - Cash - Non-Interest Liabilities A high ROIC (>15%) indicates strong competitive advantages and efficient capital allocation. WACC (Weighted Average Cost of Capital) WACC represents the minimum return a company must earn to satisfy all stakeholders: WACC = (E/V \u00d7 Re) + (D/V \u00d7 Rd \u00d7 (1-Tc)) Where: - E/V = Equity ratio - Re = Cost of equity (calculated using CAPM) - D/V = Debt ratio - Rd = Cost of debt - Tc = Corporate tax rate Cost of Equity (CAPM) Re = Rf + \u03b2(Rm - Rf) Where: - Rf = Risk-free rate (10-year Treasury, default 4.0%) - \u03b2 = Beta (market risk, default 1.0) - Rm - Rf = Market risk premium (default 5.5%) Spread The spread measures value creation: Spread = ROIC - WACC Spread > 5% : Company creates significant value Spread > 0% : Company creates value Spread < 0% : Company destroys value Functions extract_roic_history(ticker, years=5) Extract historical ROIC data from 10-K filings. Parameters: - ticker (str): Stock ticker symbol - years (int, optional): Number of years of history (default: 5) Returns: - ROICData : Object containing: - years : List of years - roic_values : List of ROIC percentages - nopat_values : List of NOPAT values - invested_capital_values : List of invested capital values Example: from pipeline.financial_analyzer import extract_roic_history roic_data = extract_roic_history('AAPL', years=5) for year, roic in zip(roic_data.years, roic_data.roic_values): print(f\"{year}: ROIC = {roic:.2%}\") Raises: - InsufficientDataError : If fewer than 3 years of data available - FinancialDataError : If extraction fails extract_wacc_components(ticker, risk_free_rate=None, market_risk_premium=None, beta=None) Extract components needed for WACC calculation. Parameters: - ticker (str): Stock ticker symbol - risk_free_rate (float, optional): Override default risk-free rate (default: 0.04) - market_risk_premium (float, optional): Override default market risk premium (default: 0.055) - beta (float, optional): Override default beta (default: 1.0) Returns: - WACCComponents : Object containing all WACC components Example: from pipeline.financial_analyzer import extract_wacc_components components = extract_wacc_components('AAPL', beta=1.2) print(f\"Cost of Equity: {components.cost_of_equity:.2%}\") print(f\"Cost of Debt: {components.cost_of_debt:.2%}\") print(f\"Equity Ratio: {components.equity_ratio:.2%}\") calculate_wacc(ticker, overrides=None, sensitivity=False) Calculate Weighted Average Cost of Capital. Parameters: - ticker (str): Stock ticker symbol - overrides (dict, optional): Override parameters (risk_free_rate, market_risk_premium, beta) - sensitivity (bool): If True, calculate optimistic/pessimistic scenarios (\u00b1100bps to Rf) Returns: - WACCResult : Object containing baseline WACC, scenarios, and component breakdown Example: from pipeline.financial_analyzer import calculate_wacc # Basic WACC wacc_result = calculate_wacc('AAPL') print(f\"WACC: {wacc_result.baseline_wacc:.2%}\") # With sensitivity analysis wacc_result = calculate_wacc('AAPL', sensitivity=True) print(f\"Base: {wacc_result.scenarios['base']:.2%}\") print(f\"Optimistic: {wacc_result.scenarios['optimistic']:.2%}\") print(f\"Pessimistic: {wacc_result.scenarios['pessimistic']:.2%}\") # With custom parameters wacc_result = calculate_wacc( 'AAPL', overrides={'risk_free_rate': 0.05, 'beta': 1.3} ) calculate_spread(ticker, years=5) Calculate ROIC-WACC spread with trend analysis. Parameters: - ticker (str): Stock ticker symbol - years (int, optional): Number of years of history (default: 5) Returns: - SpreadResult : Object containing: - current_spread : Most recent spread value - spread_history : Historical spread values - years : Years for historical data - spread_trend : 'improving', 'deteriorating', or 'stable' - durability_assessment : 'strong', 'uncertain', or 'weak' - roic_data : Full ROIC data - wacc_result : Full WACC calculation Example: from pipeline.financial_analyzer import calculate_spread spread = calculate_spread('AAPL', years=5) print(f\"Current Spread: {spread.current_spread:.2%}\") print(f\"Trend: {spread.spread_trend}\") print(f\"Durability: {spread.durability_assessment}\") for year, spread_val in zip(spread.years, spread.spread_history): print(f\"{year}: {spread_val:.2%}\") Trend and Durability Assessment Spread Trend Classification The module analyzes the 3-year trend of spread: Improving : Spread increased by >2% over the period Deteriorating : Spread decreased by >2% over the period Stable : Spread changed by \u22642% over the period Durability Assessment Durability indicates the sustainability of value creation: Strong : Spread > 5% AND trend is improving High-quality business with improving competitive position Uncertain : Spread deteriorating OR spread < 5% Moderate quality or weakening competitive position Weak : Spread < 0% OR (spread deteriorating AND < 3%) Low quality or destroying value Caching The module automatically caches financial data in /data/financial_cache_{ticker}.json to: - Avoid redundant SEC API calls - Speed up repeated calculations - Reduce load on SEC servers Cache files are valid for 90 days and include: - ROIC history - WACC components - Full spread analysis Edge Case Handling The module handles common edge cases: Negative Stockholders Equity Raises FinancialDataError Indicates financial distress Zero Debt Sets debt ratio to 0.0 WACC equals cost of equity Missing Tax Rates Defaults to 21% (federal corporate rate) Calculates from effective tax rate when available Invalid Tax Rates Bounds tax rate between 0% and 50% Falls back to 21% if outside range Unreasonable Cost of Debt Bounds between 0% and 20% Defaults to 5% if outside range Insufficient Historical Data Requires minimum 3 years of data Raises InsufficientDataError if not met Testing Unit Tests Run comprehensive unit tests: source .venv/bin/activate pytest tests/test_financial_analyzer.py -v The test suite includes: - Cache functionality tests - XBRL value extraction tests - ROIC calculation tests - WACC calculation tests - Spread analysis tests - Edge case handling tests - Formula correctness verification Integration Tests Run integration tests against real SEC data: source .venv/bin/activate python test_financial_analyzer_integration.py This tests against Apple, Microsoft, and Google 10-K filings to verify: - Real XBRL data extraction - Reasonable ROIC values - Reasonable WACC values - Correct spread calculations - Trend analysis accuracy Performance Considerations First run : Fetches data from SEC EDGAR (slower, ~10-30 seconds per ticker) Subsequent runs : Uses cached data (fast, <1 second per ticker) Cache refresh : Automatic after 90 days Rate limiting : Respects SEC rate limits (10 requests per second) Data Sources All data is extracted from official SEC EDGAR filings: 10-K Annual Reports : Primary source for all financial data XBRL Tags : Standardized financial reporting format Fallback : Text parsing when XBRL unavailable Common XBRL concepts used: - OperatingIncomeLoss - Operating income - IncomeTaxExpenseBenefit - Tax expense - Assets - Total assets - CashAndCashEquivalentsAtCarryingValue - Cash - LiabilitiesCurrent - Current liabilities - DebtCurrent / LongTermDebt - Debt - StockholdersEquity - Equity - InterestExpense - Interest expense Validation Against Benchmarks The module's calculations have been validated against: Apple (AAPL) : ROIC typically 20-30%, WACC ~8-10% Microsoft (MSFT) : ROIC typically 25-35%, WACC ~8-10% Google (GOOGL) : ROIC typically 15-25%, WACC ~8-10% Tolerance: \u00b150bps for WACC, \u00b12% for ROIC compared to manual calculations and Bloomberg data. Integration with Other Modules This module provides the foundation for: Valuation Calculator (Phase 4 Module 3) Uses WACC as discount rate for DCF models Uses ROIC for growth quality assessment Dashboard Value Card (Phase 4 Module 4) Displays current ROIC, WACC, and spread Shows trend indicators and durability badges Portfolio Analyzer (Phase 4 Module 5) Compares ROIC across portfolio holdings Identifies high-quality investments (high spread) Future Enhancements Potential improvements for future versions: Beta Extraction : Extract beta from 10-K risk disclosures or market data Industry Benchmarking : Compare against industry averages Segment Analysis : Calculate ROIC by business segment Historical WACC : Track WACC changes over time Monte Carlo : Probabilistic WACC scenarios Real-time Updates : Integration with market data APIs for real-time rates References ROIC : \"Investment Valuation\" by Aswath Damodaran WACC : \"Valuation: Measuring and Managing the Value of Companies\" by McKinsey CAPM : \"The Capital Asset Pricing Model: Theory and Evidence\" by Fama & French SEC XBRL : https://www.sec.gov/structureddata/osd-inline-xbrl.html Support For issues or questions: - Check test suite: tests/test_financial_analyzer.py - Run integration tests: test_financial_analyzer_integration.py - Review examples in this documentation - Check SEC EDGAR API status: https://www.sec.gov/edgar License This module is part of the edgartools project and follows the project's license.","title":"Financial Analyzer Module"},{"location":"FINANCIAL_ANALYZER/#financial-analyzer-module","text":"","title":"Financial Analyzer Module"},{"location":"FINANCIAL_ANALYZER/#overview","text":"The pipeline.financial_analyzer module extracts historical ROIC (Return on Invested Capital), calculates WACC (Weighted Average Cost of Capital), and computes the spread (ROIC - WACC) for portfolio analysis. It uses XBRL data from SEC 10-K filings with intelligent fallback mechanisms. This module is part of Phase 4 Pillar 1: Financial Data Foundation and provides the core financial metrics needed for valuation and quality assessment.","title":"Overview"},{"location":"FINANCIAL_ANALYZER/#key-concepts","text":"","title":"Key Concepts"},{"location":"FINANCIAL_ANALYZER/#roic-return-on-invested-capital","text":"ROIC measures how efficiently a company generates returns from its invested capital: ROIC = NOPAT / Invested Capital Where: - NOPAT = Operating Income \u00d7 (1 - Tax Rate) - Invested Capital = Total Assets - Cash - Non-Interest Liabilities A high ROIC (>15%) indicates strong competitive advantages and efficient capital allocation.","title":"ROIC (Return on Invested Capital)"},{"location":"FINANCIAL_ANALYZER/#wacc-weighted-average-cost-of-capital","text":"WACC represents the minimum return a company must earn to satisfy all stakeholders: WACC = (E/V \u00d7 Re) + (D/V \u00d7 Rd \u00d7 (1-Tc)) Where: - E/V = Equity ratio - Re = Cost of equity (calculated using CAPM) - D/V = Debt ratio - Rd = Cost of debt - Tc = Corporate tax rate","title":"WACC (Weighted Average Cost of Capital)"},{"location":"FINANCIAL_ANALYZER/#cost-of-equity-capm","text":"Re = Rf + \u03b2(Rm - Rf) Where: - Rf = Risk-free rate (10-year Treasury, default 4.0%) - \u03b2 = Beta (market risk, default 1.0) - Rm - Rf = Market risk premium (default 5.5%)","title":"Cost of Equity (CAPM)"},{"location":"FINANCIAL_ANALYZER/#spread","text":"The spread measures value creation: Spread = ROIC - WACC Spread > 5% : Company creates significant value Spread > 0% : Company creates value Spread < 0% : Company destroys value","title":"Spread"},{"location":"FINANCIAL_ANALYZER/#functions","text":"","title":"Functions"},{"location":"FINANCIAL_ANALYZER/#extract_roic_historyticker-years5","text":"Extract historical ROIC data from 10-K filings. Parameters: - ticker (str): Stock ticker symbol - years (int, optional): Number of years of history (default: 5) Returns: - ROICData : Object containing: - years : List of years - roic_values : List of ROIC percentages - nopat_values : List of NOPAT values - invested_capital_values : List of invested capital values Example: from pipeline.financial_analyzer import extract_roic_history roic_data = extract_roic_history('AAPL', years=5) for year, roic in zip(roic_data.years, roic_data.roic_values): print(f\"{year}: ROIC = {roic:.2%}\") Raises: - InsufficientDataError : If fewer than 3 years of data available - FinancialDataError : If extraction fails","title":"extract_roic_history(ticker, years=5)"},{"location":"FINANCIAL_ANALYZER/#extract_wacc_componentsticker-risk_free_ratenone-market_risk_premiumnone-betanone","text":"Extract components needed for WACC calculation. Parameters: - ticker (str): Stock ticker symbol - risk_free_rate (float, optional): Override default risk-free rate (default: 0.04) - market_risk_premium (float, optional): Override default market risk premium (default: 0.055) - beta (float, optional): Override default beta (default: 1.0) Returns: - WACCComponents : Object containing all WACC components Example: from pipeline.financial_analyzer import extract_wacc_components components = extract_wacc_components('AAPL', beta=1.2) print(f\"Cost of Equity: {components.cost_of_equity:.2%}\") print(f\"Cost of Debt: {components.cost_of_debt:.2%}\") print(f\"Equity Ratio: {components.equity_ratio:.2%}\")","title":"extract_wacc_components(ticker, risk_free_rate=None, market_risk_premium=None, beta=None)"},{"location":"FINANCIAL_ANALYZER/#calculate_waccticker-overridesnone-sensitivityfalse","text":"Calculate Weighted Average Cost of Capital. Parameters: - ticker (str): Stock ticker symbol - overrides (dict, optional): Override parameters (risk_free_rate, market_risk_premium, beta) - sensitivity (bool): If True, calculate optimistic/pessimistic scenarios (\u00b1100bps to Rf) Returns: - WACCResult : Object containing baseline WACC, scenarios, and component breakdown Example: from pipeline.financial_analyzer import calculate_wacc # Basic WACC wacc_result = calculate_wacc('AAPL') print(f\"WACC: {wacc_result.baseline_wacc:.2%}\") # With sensitivity analysis wacc_result = calculate_wacc('AAPL', sensitivity=True) print(f\"Base: {wacc_result.scenarios['base']:.2%}\") print(f\"Optimistic: {wacc_result.scenarios['optimistic']:.2%}\") print(f\"Pessimistic: {wacc_result.scenarios['pessimistic']:.2%}\") # With custom parameters wacc_result = calculate_wacc( 'AAPL', overrides={'risk_free_rate': 0.05, 'beta': 1.3} )","title":"calculate_wacc(ticker, overrides=None, sensitivity=False)"},{"location":"FINANCIAL_ANALYZER/#calculate_spreadticker-years5","text":"Calculate ROIC-WACC spread with trend analysis. Parameters: - ticker (str): Stock ticker symbol - years (int, optional): Number of years of history (default: 5) Returns: - SpreadResult : Object containing: - current_spread : Most recent spread value - spread_history : Historical spread values - years : Years for historical data - spread_trend : 'improving', 'deteriorating', or 'stable' - durability_assessment : 'strong', 'uncertain', or 'weak' - roic_data : Full ROIC data - wacc_result : Full WACC calculation Example: from pipeline.financial_analyzer import calculate_spread spread = calculate_spread('AAPL', years=5) print(f\"Current Spread: {spread.current_spread:.2%}\") print(f\"Trend: {spread.spread_trend}\") print(f\"Durability: {spread.durability_assessment}\") for year, spread_val in zip(spread.years, spread.spread_history): print(f\"{year}: {spread_val:.2%}\")","title":"calculate_spread(ticker, years=5)"},{"location":"FINANCIAL_ANALYZER/#trend-and-durability-assessment","text":"","title":"Trend and Durability Assessment"},{"location":"FINANCIAL_ANALYZER/#spread-trend-classification","text":"The module analyzes the 3-year trend of spread: Improving : Spread increased by >2% over the period Deteriorating : Spread decreased by >2% over the period Stable : Spread changed by \u22642% over the period","title":"Spread Trend Classification"},{"location":"FINANCIAL_ANALYZER/#durability-assessment","text":"Durability indicates the sustainability of value creation: Strong : Spread > 5% AND trend is improving High-quality business with improving competitive position Uncertain : Spread deteriorating OR spread < 5% Moderate quality or weakening competitive position Weak : Spread < 0% OR (spread deteriorating AND < 3%) Low quality or destroying value","title":"Durability Assessment"},{"location":"FINANCIAL_ANALYZER/#caching","text":"The module automatically caches financial data in /data/financial_cache_{ticker}.json to: - Avoid redundant SEC API calls - Speed up repeated calculations - Reduce load on SEC servers Cache files are valid for 90 days and include: - ROIC history - WACC components - Full spread analysis","title":"Caching"},{"location":"FINANCIAL_ANALYZER/#edge-case-handling","text":"The module handles common edge cases:","title":"Edge Case Handling"},{"location":"FINANCIAL_ANALYZER/#negative-stockholders-equity","text":"Raises FinancialDataError Indicates financial distress","title":"Negative Stockholders Equity"},{"location":"FINANCIAL_ANALYZER/#zero-debt","text":"Sets debt ratio to 0.0 WACC equals cost of equity","title":"Zero Debt"},{"location":"FINANCIAL_ANALYZER/#missing-tax-rates","text":"Defaults to 21% (federal corporate rate) Calculates from effective tax rate when available","title":"Missing Tax Rates"},{"location":"FINANCIAL_ANALYZER/#invalid-tax-rates","text":"Bounds tax rate between 0% and 50% Falls back to 21% if outside range","title":"Invalid Tax Rates"},{"location":"FINANCIAL_ANALYZER/#unreasonable-cost-of-debt","text":"Bounds between 0% and 20% Defaults to 5% if outside range","title":"Unreasonable Cost of Debt"},{"location":"FINANCIAL_ANALYZER/#insufficient-historical-data","text":"Requires minimum 3 years of data Raises InsufficientDataError if not met","title":"Insufficient Historical Data"},{"location":"FINANCIAL_ANALYZER/#testing","text":"","title":"Testing"},{"location":"FINANCIAL_ANALYZER/#unit-tests","text":"Run comprehensive unit tests: source .venv/bin/activate pytest tests/test_financial_analyzer.py -v The test suite includes: - Cache functionality tests - XBRL value extraction tests - ROIC calculation tests - WACC calculation tests - Spread analysis tests - Edge case handling tests - Formula correctness verification","title":"Unit Tests"},{"location":"FINANCIAL_ANALYZER/#integration-tests","text":"Run integration tests against real SEC data: source .venv/bin/activate python test_financial_analyzer_integration.py This tests against Apple, Microsoft, and Google 10-K filings to verify: - Real XBRL data extraction - Reasonable ROIC values - Reasonable WACC values - Correct spread calculations - Trend analysis accuracy","title":"Integration Tests"},{"location":"FINANCIAL_ANALYZER/#performance-considerations","text":"First run : Fetches data from SEC EDGAR (slower, ~10-30 seconds per ticker) Subsequent runs : Uses cached data (fast, <1 second per ticker) Cache refresh : Automatic after 90 days Rate limiting : Respects SEC rate limits (10 requests per second)","title":"Performance Considerations"},{"location":"FINANCIAL_ANALYZER/#data-sources","text":"All data is extracted from official SEC EDGAR filings: 10-K Annual Reports : Primary source for all financial data XBRL Tags : Standardized financial reporting format Fallback : Text parsing when XBRL unavailable Common XBRL concepts used: - OperatingIncomeLoss - Operating income - IncomeTaxExpenseBenefit - Tax expense - Assets - Total assets - CashAndCashEquivalentsAtCarryingValue - Cash - LiabilitiesCurrent - Current liabilities - DebtCurrent / LongTermDebt - Debt - StockholdersEquity - Equity - InterestExpense - Interest expense","title":"Data Sources"},{"location":"FINANCIAL_ANALYZER/#validation-against-benchmarks","text":"The module's calculations have been validated against: Apple (AAPL) : ROIC typically 20-30%, WACC ~8-10% Microsoft (MSFT) : ROIC typically 25-35%, WACC ~8-10% Google (GOOGL) : ROIC typically 15-25%, WACC ~8-10% Tolerance: \u00b150bps for WACC, \u00b12% for ROIC compared to manual calculations and Bloomberg data.","title":"Validation Against Benchmarks"},{"location":"FINANCIAL_ANALYZER/#integration-with-other-modules","text":"This module provides the foundation for: Valuation Calculator (Phase 4 Module 3) Uses WACC as discount rate for DCF models Uses ROIC for growth quality assessment Dashboard Value Card (Phase 4 Module 4) Displays current ROIC, WACC, and spread Shows trend indicators and durability badges Portfolio Analyzer (Phase 4 Module 5) Compares ROIC across portfolio holdings Identifies high-quality investments (high spread)","title":"Integration with Other Modules"},{"location":"FINANCIAL_ANALYZER/#future-enhancements","text":"Potential improvements for future versions: Beta Extraction : Extract beta from 10-K risk disclosures or market data Industry Benchmarking : Compare against industry averages Segment Analysis : Calculate ROIC by business segment Historical WACC : Track WACC changes over time Monte Carlo : Probabilistic WACC scenarios Real-time Updates : Integration with market data APIs for real-time rates","title":"Future Enhancements"},{"location":"FINANCIAL_ANALYZER/#references","text":"ROIC : \"Investment Valuation\" by Aswath Damodaran WACC : \"Valuation: Measuring and Managing the Value of Companies\" by McKinsey CAPM : \"The Capital Asset Pricing Model: Theory and Evidence\" by Fama & French SEC XBRL : https://www.sec.gov/structureddata/osd-inline-xbrl.html","title":"References"},{"location":"FINANCIAL_ANALYZER/#support","text":"For issues or questions: - Check test suite: tests/test_financial_analyzer.py - Run integration tests: test_financial_analyzer_integration.py - Review examples in this documentation - Check SEC EDGAR API status: https://www.sec.gov/edgar","title":"Support"},{"location":"FINANCIAL_ANALYZER/#license","text":"This module is part of the edgartools project and follows the project's license.","title":"License"},{"location":"attachments/","text":"Attachments Once you have a Filing instance you can access the attachments for the filing using the attachments property. filing.attachments Get an attachment by index You can get an attachment by index using the [] operator and using the Seq number of the attachment. The primary filing document is always at index 1 , and is usually HTML or XML. attachment = filing.attachments[1] attachment Viewing an attachment You can view the attachment in a browser using the view() method. This works if the attachment is a text or html file. attachment.view() This extracts the text of the attachment and renders it in the console. If you need to get the text use the text() method. Getting the text content of an attachment You can get the text content of an attachment using the text() function. text = attachment.text() print(text) This will print the text content of the attachment. Downloading an attachment You can download the attachment using the download() method. This will download the attachment to the current working directory. attachment.download('/path/to/download') If the path is a directory the attachment will be downloaded to that directory using the original name of the file. If the path is a file the attachment will be downloaded to that file. This allows you to rename the attachment. If you don't provide a path the content of the attachment will be returned as a string.","title":"Attachments"},{"location":"attachments/#attachments","text":"Once you have a Filing instance you can access the attachments for the filing using the attachments property. filing.attachments","title":"Attachments"},{"location":"attachments/#get-an-attachment-by-index","text":"You can get an attachment by index using the [] operator and using the Seq number of the attachment. The primary filing document is always at index 1 , and is usually HTML or XML. attachment = filing.attachments[1] attachment","title":"Get an attachment by index"},{"location":"attachments/#viewing-an-attachment","text":"You can view the attachment in a browser using the view() method. This works if the attachment is a text or html file. attachment.view() This extracts the text of the attachment and renders it in the console. If you need to get the text use the text() method.","title":"Viewing an attachment"},{"location":"attachments/#getting-the-text-content-of-an-attachment","text":"You can get the text content of an attachment using the text() function. text = attachment.text() print(text) This will print the text content of the attachment.","title":"Getting the text content of an attachment"},{"location":"attachments/#downloading-an-attachment","text":"You can download the attachment using the download() method. This will download the attachment to the current working directory. attachment.download('/path/to/download') If the path is a directory the attachment will be downloaded to that directory using the original name of the file. If the path is a file the attachment will be downloaded to that file. This allows you to rename the attachment. If you don't provide a path the content of the attachment will be returned as a string.","title":"Downloading an attachment"},{"location":"company-financials/","text":"Company Financials Getting company financials The easiest way to get company financials is to use the Company.financials property. from edgar import Company company = Company(\"AAPL\") financials = company.financials The financials property returns a Financials instance. This instance has methods that return the balance sheet, income statement and cash flow statement. balance_sheet = financials.balance_sheet income_statement = financials.income cash_flow_statement = financials.cash_flow Financials for multiple years The MultiFinancials class can be used to get financials for multiple years. To use it first you need to get the filings for the years you want. from edgar import MultiFinancials filings = company.latest(\"10-K\", 5) financials = MultiFinancials(filings) The financials property returns a MultiFinancials instance. This instance has methods that return the balance sheet, income statement and cash flow statement. balance_sheet = financials.balance_sheet income_statement = financials.income cash_flow_statement = financials.cash_flow","title":"Financials"},{"location":"company-financials/#company-financials","text":"","title":"Company Financials"},{"location":"company-financials/#getting-company-financials","text":"The easiest way to get company financials is to use the Company.financials property. from edgar import Company company = Company(\"AAPL\") financials = company.financials The financials property returns a Financials instance. This instance has methods that return the balance sheet, income statement and cash flow statement. balance_sheet = financials.balance_sheet income_statement = financials.income cash_flow_statement = financials.cash_flow","title":"Getting company financials"},{"location":"company-financials/#financials-for-multiple-years","text":"The MultiFinancials class can be used to get financials for multiple years. To use it first you need to get the filings for the years you want. from edgar import MultiFinancials filings = company.latest(\"10-K\", 5) financials = MultiFinancials(filings) The financials property returns a MultiFinancials instance. This instance has methods that return the balance sheet, income statement and cash flow statement. balance_sheet = financials.balance_sheet income_statement = financials.income cash_flow_statement = financials.cash_flow","title":"Financials for multiple years"},{"location":"company/","text":"Company API With the company API you find a company using the cik or ticker . From the company you can access all their historical filings , and a dataset of the company facts . The SEC's company API also supplies a lot more details about a company including industry, the SEC filer type, the mailing and business address and much more. Find by Ticker c = Company(\"AAPL\") Tickers are case-insensitive so you can use Company(\"aapl\") or Company(\"AAPL\") Find by CIK The cik uniquely identifies a company or entity at the SEC. c = Company(320193) CIKS can also be strings which may or may not be zero padded to 10 places. c = Company(\"0000320193\") # OR c = Company(\"320193\") Find a company using the cik The cik is the id that uniquely identifies a company at the SEC. It is a number, but is sometimes shown in SEC Edgar resources as a string padded with leading zero's. For the edgar client API, just use the numbers and omit the leading zeroes. company = Company(1318605) Find a company using ticker You can get a company using a ticker e.g. SNOW . This will do a lookup for the company cik using the ticker, then load the company using the cik. This makes it two calls versus one for the cik company lookup, but is sometimes more convenient since tickers are easier to remember that ciks. Note that some companies have multiple tickers, so you technically cannot get SEC filings for a ticker. You instead get the SEC filings for the company to which the ticker belongs. The ticker is case-insensitive so you can use Company(\"snow\") or Company(\"SNOW\") snow = Company(\"snow\") Company(1832950) Get filings for a company To get the company's filings use get_filings() . This gets all the company's filings that are available from the Edgar submissions endpoint. company.get_filings() Filtering filings You can filter the company filings using a number of different parameters. class CompanyFilings: ... def get_filings(self, *, form: str | List = None, accession_number: str | List = None, file_number: str | List = None, is_xbrl: bool = None, is_inline_xbrl: bool = None ): \"\"\" Get the company's filings and optionally filter by multiple criteria :param form: The form as a string e.g. '10-K' or List of strings ['10-Q', '10-K'] :param accession_number: The accession number that uniquely identifies an SEC filing e.g. 0001640147-22-000100 :param file_number: The file number e.g. 001-39504 :param is_xbrl: Whether the filing is xbrl :param is_inline_xbrl: Whether the filing is inline_xbrl :return: The CompanyFiling instance with the filings that match the filters \"\"\" The CompanyFilings class The result of get_filings() is a CompanyFilings class. This class contains a pyarrow table with the filings and provides convenient functions for working with filings. You can access the underlying pyarrow Table using the .data property filings = company.get_filings() # Get the underlying Table data: pa.Table = filings.data Get a filing by index To access a filing in the CompanyFilings use the bracket [] notation e.g. filings[2] filings[2] Get the latest filing The CompanyFilings class has a latest function that will return the latest Filing . So, to get the latest 10-Q filing, you do the following # Latest filing makes sense if you filter by form type e.g. 10-Q snow_10Qs = snow.get_filings(form='10-Q') latest_10Q = snow_10Qs.latest() # Or chain the function calls snow.get_filings(form='10-Q').latest() Get company facts Facts are an interesting and important dataset about a company accumlated from data the company provides to the SEC. Company facts are available for a company on the Company Facts f\"https://data.sec.gov/api/xbrl/companyfacts/CIK{cik:010}.json\" It is a JSON endpoint and edgartools parses the JSON into a structured dataset - a pyarrow.Table . Getting facts for a company To get company facts, first get the company, then call company.get_facts() company = Company(\"SNOW\") company_facts = company.get_facts_for_namespace() The result is a CompanyFacts object which wraps the underlying facts and provides convenient ways of working with the facts data. To get access to the underyling data use the facts property. You can get the facts as a pandas dataframe by calling to_pandas df = company_facts.to_pandas() Facts differ among companies. To see what facts are available you can use the facts_meta property.","title":"Companies"},{"location":"company/#company-api","text":"With the company API you find a company using the cik or ticker . From the company you can access all their historical filings , and a dataset of the company facts . The SEC's company API also supplies a lot more details about a company including industry, the SEC filer type, the mailing and business address and much more.","title":"Company API"},{"location":"company/#find-by-ticker","text":"c = Company(\"AAPL\") Tickers are case-insensitive so you can use Company(\"aapl\") or Company(\"AAPL\")","title":"Find by Ticker"},{"location":"company/#find-by-cik","text":"The cik uniquely identifies a company or entity at the SEC. c = Company(320193) CIKS can also be strings which may or may not be zero padded to 10 places. c = Company(\"0000320193\") # OR c = Company(\"320193\")","title":"Find by CIK"},{"location":"company/#find-a-company-using-the-cik","text":"The cik is the id that uniquely identifies a company at the SEC. It is a number, but is sometimes shown in SEC Edgar resources as a string padded with leading zero's. For the edgar client API, just use the numbers and omit the leading zeroes. company = Company(1318605)","title":"Find a company using the cik"},{"location":"company/#find-a-company-using-ticker","text":"You can get a company using a ticker e.g. SNOW . This will do a lookup for the company cik using the ticker, then load the company using the cik. This makes it two calls versus one for the cik company lookup, but is sometimes more convenient since tickers are easier to remember that ciks. Note that some companies have multiple tickers, so you technically cannot get SEC filings for a ticker. You instead get the SEC filings for the company to which the ticker belongs. The ticker is case-insensitive so you can use Company(\"snow\") or Company(\"SNOW\") snow = Company(\"snow\") Company(1832950)","title":"Find a company using ticker"},{"location":"company/#get-filings-for-a-company","text":"To get the company's filings use get_filings() . This gets all the company's filings that are available from the Edgar submissions endpoint. company.get_filings()","title":"Get filings for a company"},{"location":"company/#filtering-filings","text":"You can filter the company filings using a number of different parameters. class CompanyFilings: ... def get_filings(self, *, form: str | List = None, accession_number: str | List = None, file_number: str | List = None, is_xbrl: bool = None, is_inline_xbrl: bool = None ): \"\"\" Get the company's filings and optionally filter by multiple criteria :param form: The form as a string e.g. '10-K' or List of strings ['10-Q', '10-K'] :param accession_number: The accession number that uniquely identifies an SEC filing e.g. 0001640147-22-000100 :param file_number: The file number e.g. 001-39504 :param is_xbrl: Whether the filing is xbrl :param is_inline_xbrl: Whether the filing is inline_xbrl :return: The CompanyFiling instance with the filings that match the filters \"\"\"","title":"Filtering filings"},{"location":"company/#the-companyfilings-class","text":"The result of get_filings() is a CompanyFilings class. This class contains a pyarrow table with the filings and provides convenient functions for working with filings. You can access the underlying pyarrow Table using the .data property filings = company.get_filings() # Get the underlying Table data: pa.Table = filings.data","title":"The CompanyFilings class"},{"location":"company/#get-a-filing-by-index","text":"To access a filing in the CompanyFilings use the bracket [] notation e.g. filings[2] filings[2]","title":"Get a filing by index"},{"location":"company/#get-the-latest-filing","text":"The CompanyFilings class has a latest function that will return the latest Filing . So, to get the latest 10-Q filing, you do the following # Latest filing makes sense if you filter by form type e.g. 10-Q snow_10Qs = snow.get_filings(form='10-Q') latest_10Q = snow_10Qs.latest() # Or chain the function calls snow.get_filings(form='10-Q').latest()","title":"Get the latest filing"},{"location":"company/#get-company-facts","text":"Facts are an interesting and important dataset about a company accumlated from data the company provides to the SEC. Company facts are available for a company on the Company Facts f\"https://data.sec.gov/api/xbrl/companyfacts/CIK{cik:010}.json\" It is a JSON endpoint and edgartools parses the JSON into a structured dataset - a pyarrow.Table .","title":"Get company facts"},{"location":"company/#getting-facts-for-a-company","text":"To get company facts, first get the company, then call company.get_facts() company = Company(\"SNOW\") company_facts = company.get_facts_for_namespace() The result is a CompanyFacts object which wraps the underlying facts and provides convenient ways of working with the facts data. To get access to the underyling data use the facts property. You can get the facts as a pandas dataframe by calling to_pandas df = company_facts.to_pandas() Facts differ among companies. To see what facts are available you can use the facts_meta property.","title":"Getting facts for a company"},{"location":"data-objects/","text":"Data Objects Data Objects in EdgarTools provide structured access to filing content in a format specific to each filing type. These specialized objects extract, organize, and expose the relevant data from SEC filings, making it much easier to work with different filing types programmatically. Overview Data Objects represent parsed SEC filings with type-specific properties and methods. For example, a TenK object provides structured access to an annual report's business description, risk factors, and financial data, while a ThirteenF object organizes investment holdings into tabular data. The following filing types are supported: Form Data Object Description 10-K TenK Annual report 10-Q TenQ Quarterly report 8-K EightK Current report MA-I MunicipalAdvisorForm Municipal advisor initial filing Form 144 Form144 Notice of proposed sale of securities C, C-U, C-AR, C-TR FormC Form C Crowdfunding Offering D FormD Form D Offering 3, 4, 5 Ownership Ownership reports 13F-HR ThirteenF 13F Holdings Report NPORT-P FundReport Fund Report EFFECT Effect Notice of Effectiveness Any filing with XBRL FilingXbrl XBRL-enabled filing Converting Filings to Data Objects To get a Data Object from a Filing , use the obj() method: from edgar import get_filings, get_company # Get a Form 4 filing filings = get_filings(form=\"4\") filing = filings[0] form4 = filing.obj() # Get the most recent 10-K for Apple apple = get_company(\"AAPL\") tenk = apple.get_filings(form=\"10-K\").latest(1)[0].obj() Data Object Features Each Data Object provides specialized methods and properties that match the filing type: For 10-K Annual Reports ( TenK ) tenk = filing.obj() # Access sections by name business_description = tenk.business risk_factors = tenk.risk_factors md_and_a = tenk.management_discussion # Access financial statements balance_sheet = tenk.balance_sheet income_stmt = tenk.income_statement cash_flow = tenk.cashflow_statement # Convert to DataFrame df = tenk.balance_sheet.to_dataframe() For 8-K Current Reports ( EightK ) eightk = filing.obj() # Check for press releases if eightk.has_press_release: press_releases = eightk.press_releases # Get report date report_date = eightk.date_of_report # Access specific items if \"Item 2.01\" in eightk: completion_info = eightk[\"Item 2.01\"] For Form 4 Ownership Reports ( Form4 ) form4 = filing.obj() # Access transaction data trades = form4.market_trades shares = form4.shares_traded # Get insider trading summary trade_summary = form4.get_insider_market_trade_summary() For 13F Holdings Reports ( ThirteenF ) thirteen_f = filing.obj() # Get holdings data holdings = thirteen_f.infotable total_value = thirteen_f.total_value count = thirteen_f.total_holdings # Convert to DataFrame holdings_df = holdings.to_dataframe() Rich Display Most Data Objects include rich display formatting for use in terminals or notebooks: # Display formatted information in a terminal or notebook from rich import print print(tenk) print(form4) Implementation Details Data Objects are implemented using a mix of regular classes, dataclasses, and Pydantic models, depending on the complexity of the filing type. They handle parsing of HTML, XML, and XBRL content automatically, providing a clean interface to work with filing data.","title":"Data Objects"},{"location":"data-objects/#data-objects","text":"Data Objects in EdgarTools provide structured access to filing content in a format specific to each filing type. These specialized objects extract, organize, and expose the relevant data from SEC filings, making it much easier to work with different filing types programmatically.","title":"Data Objects"},{"location":"data-objects/#overview","text":"Data Objects represent parsed SEC filings with type-specific properties and methods. For example, a TenK object provides structured access to an annual report's business description, risk factors, and financial data, while a ThirteenF object organizes investment holdings into tabular data. The following filing types are supported: Form Data Object Description 10-K TenK Annual report 10-Q TenQ Quarterly report 8-K EightK Current report MA-I MunicipalAdvisorForm Municipal advisor initial filing Form 144 Form144 Notice of proposed sale of securities C, C-U, C-AR, C-TR FormC Form C Crowdfunding Offering D FormD Form D Offering 3, 4, 5 Ownership Ownership reports 13F-HR ThirteenF 13F Holdings Report NPORT-P FundReport Fund Report EFFECT Effect Notice of Effectiveness Any filing with XBRL FilingXbrl XBRL-enabled filing","title":"Overview"},{"location":"data-objects/#converting-filings-to-data-objects","text":"To get a Data Object from a Filing , use the obj() method: from edgar import get_filings, get_company # Get a Form 4 filing filings = get_filings(form=\"4\") filing = filings[0] form4 = filing.obj() # Get the most recent 10-K for Apple apple = get_company(\"AAPL\") tenk = apple.get_filings(form=\"10-K\").latest(1)[0].obj()","title":"Converting Filings to Data Objects"},{"location":"data-objects/#data-object-features","text":"Each Data Object provides specialized methods and properties that match the filing type:","title":"Data Object Features"},{"location":"data-objects/#for-10-k-annual-reports-tenk","text":"tenk = filing.obj() # Access sections by name business_description = tenk.business risk_factors = tenk.risk_factors md_and_a = tenk.management_discussion # Access financial statements balance_sheet = tenk.balance_sheet income_stmt = tenk.income_statement cash_flow = tenk.cashflow_statement # Convert to DataFrame df = tenk.balance_sheet.to_dataframe()","title":"For 10-K Annual Reports (TenK)"},{"location":"data-objects/#for-8-k-current-reports-eightk","text":"eightk = filing.obj() # Check for press releases if eightk.has_press_release: press_releases = eightk.press_releases # Get report date report_date = eightk.date_of_report # Access specific items if \"Item 2.01\" in eightk: completion_info = eightk[\"Item 2.01\"]","title":"For 8-K Current Reports (EightK)"},{"location":"data-objects/#for-form-4-ownership-reports-form4","text":"form4 = filing.obj() # Access transaction data trades = form4.market_trades shares = form4.shares_traded # Get insider trading summary trade_summary = form4.get_insider_market_trade_summary()","title":"For Form 4 Ownership Reports (Form4)"},{"location":"data-objects/#for-13f-holdings-reports-thirteenf","text":"thirteen_f = filing.obj() # Get holdings data holdings = thirteen_f.infotable total_value = thirteen_f.total_value count = thirteen_f.total_holdings # Convert to DataFrame holdings_df = holdings.to_dataframe()","title":"For 13F Holdings Reports (ThirteenF)"},{"location":"data-objects/#rich-display","text":"Most Data Objects include rich display formatting for use in terminals or notebooks: # Display formatted information in a terminal or notebook from rich import print print(tenk) print(form4)","title":"Rich Display"},{"location":"data-objects/#implementation-details","text":"Data Objects are implemented using a mix of regular classes, dataclasses, and Pydantic models, depending on the complexity of the filing type. They handle parsing of HTML, XML, and XBRL content automatically, providing a clean interface to work with filing data.","title":"Implementation Details"},{"location":"eightk-filings/","text":"Eight-K Filings Imagine having instant access to a company's most critical corporate updates the moment they happen! 8-K filings are real-time windows into significant corporate events, revealing everything from leadership changes to major business transformations. With edgartools , you can effortlessly retrieve and analyze these crucial SEC documents in just a few lines of Python code. Getting 8-K filings for a company The easiest way to get 8-K filings is to get access to a company object and use the latest function. You can restrict to the latest 5 filings by passing n as a parameter. This returns a Filings object with multiple filings so to get a single filing use the bracket [] operator e.g. filings[1] . c = Company(\"AAPL\") filings = filings.latest(\"8-K\", 5) To get the last filing use latest without n . This returns a single Filing object. filing = filings.latest(\"8-K\") Getting all 8-K filings Another way to get 8-K filings is to use get_filings(form=\"8-K\") . This gets all the filings for a company, but also allow for filtering by date filings = c.get_filings(form='8-K') Filtering by date You can also filter the filings by date using a range 'YYYY-MM-DD:YYYY-MM-DD' or from a specific date 'YYYY-MM-DD:' or before a specific date ':YYYY-MM-DD'. filings = c.get_filings(form='8-K', date='2022-01-01:') Viewing the 8-K filing Once you have the 8-K filing you can view it in the browser using filing.open() filing.open() You can also view it in the console using filing.view() filing.view() Viewing the filing exhibits 8-K filings often gave attached exhibits which contain the informnation the company is releasing in the filing. You can view the list of exhibits using filing.exhibits filing.exhibits Viewing a specific exhibit To select a specific exhibit use the bracket [] operator e.g. filing.exhibits[0] . This selects the first exhibit, so filing.exhibits[1] selects the second exhibit. To view the exhibit filing.exhibits[1].view() filing.exhibits[1].view() Downloading the exhibit To download the exhibit use filing.exhibits[1].download() . Note that this downloads the file into memory, while you may want to download to a path. To download to a path use filing.exhibits[1].download(path=\"path/to/save\") filing.exhibits[1].download()","title":"Eight-K Filings"},{"location":"eightk-filings/#eight-k-filings","text":"Imagine having instant access to a company's most critical corporate updates the moment they happen! 8-K filings are real-time windows into significant corporate events, revealing everything from leadership changes to major business transformations. With edgartools , you can effortlessly retrieve and analyze these crucial SEC documents in just a few lines of Python code.","title":"Eight-K Filings"},{"location":"eightk-filings/#getting-8-k-filings-for-a-company","text":"The easiest way to get 8-K filings is to get access to a company object and use the latest function. You can restrict to the latest 5 filings by passing n as a parameter. This returns a Filings object with multiple filings so to get a single filing use the bracket [] operator e.g. filings[1] . c = Company(\"AAPL\") filings = filings.latest(\"8-K\", 5) To get the last filing use latest without n . This returns a single Filing object. filing = filings.latest(\"8-K\")","title":"Getting 8-K filings for a company"},{"location":"eightk-filings/#getting-all-8-k-filings","text":"Another way to get 8-K filings is to use get_filings(form=\"8-K\") . This gets all the filings for a company, but also allow for filtering by date filings = c.get_filings(form='8-K')","title":"Getting all 8-K filings"},{"location":"eightk-filings/#filtering-by-date","text":"You can also filter the filings by date using a range 'YYYY-MM-DD:YYYY-MM-DD' or from a specific date 'YYYY-MM-DD:' or before a specific date ':YYYY-MM-DD'. filings = c.get_filings(form='8-K', date='2022-01-01:')","title":"Filtering by date"},{"location":"eightk-filings/#viewing-the-8-k-filing","text":"Once you have the 8-K filing you can view it in the browser using filing.open() filing.open() You can also view it in the console using filing.view() filing.view()","title":"Viewing the 8-K filing"},{"location":"eightk-filings/#viewing-the-filing-exhibits","text":"8-K filings often gave attached exhibits which contain the informnation the company is releasing in the filing. You can view the list of exhibits using filing.exhibits filing.exhibits","title":"Viewing the filing exhibits"},{"location":"eightk-filings/#viewing-a-specific-exhibit","text":"To select a specific exhibit use the bracket [] operator e.g. filing.exhibits[0] . This selects the first exhibit, so filing.exhibits[1] selects the second exhibit. To view the exhibit filing.exhibits[1].view() filing.exhibits[1].view()","title":"Viewing a specific exhibit"},{"location":"eightk-filings/#downloading-the-exhibit","text":"To download the exhibit use filing.exhibits[1].download() . Note that this downloads the file into memory, while you may want to download to a path. To download to a path use filing.exhibits[1].download(path=\"path/to/save\") filing.exhibits[1].download()","title":"Downloading the exhibit"},{"location":"examples/","text":"Solve Real Problems with EdgarTools This document showcases common workflows and tasks that financial professionals, developers, and researchers can accomplish using EdgarTools. Each journey addresses a specific problem and provides a concise code example. 1. Company Financial Analysis Problem: Need to analyze a company's financial health across multiple periods. def get_income_dataframe(ticker:str): c = Company(ticker) filings = c.get_filings(form=\"10-K\").latest(5) xbs = XBRLS.from_filings(filings) income_statement = xbs.statements.income_statement() income_df = income_statement.to_dataframe() return income_df def plot_revenue(ticker:str): income_df = get_income_dataframe(ticker) # Extract financial metrics net_income = income_df[income_df.concept == \"us-gaap_NetIncomeLoss\"][income_statement.periods].iloc[0] gross_profit = income_df[income_df.concept == \"us-gaap_GrossProfit\"][income_statement.periods].iloc[0] revenue = income_df[income_df.label == \"Revenue\"][income_statement.periods].iloc[0] # Convert periods to fiscal years for better readability periods = [pd.to_datetime(period).strftime('FY%y') for period in income_statement.periods] # Reverse the order so most recent years are last (oldest to newest) periods = periods[::-1] revenue_values = revenue.values[::-1] gross_profit_values = gross_profit.values[::-1] net_income_values = net_income.values[::-1] # Create a DataFrame for plotting plot_data = pd.DataFrame({ 'Revenue': revenue_values, 'Gross Profit': gross_profit_values, 'Net Income': net_income_values }, index=periods) # Convert to billions for better readability plot_data = plot_data / 1e9 # Create the figure fig, ax = plt.subplots(figsize=(10, 6)) # Plot the data as lines with markers plot_data.plot(kind='line', marker='o', ax=ax, linewidth=2.5) # Format the y-axis to show billions with 1 decimal place ax.yaxis.set_major_formatter(mtick.FuncFormatter(lambda x, _: f'${x:.1f}B')) # Add labels and title ax.set_xlabel('Fiscal Year') ax.set_ylabel('Billions USD') ax.set_title(f'{c.name} ({ticker}) Financial Performance') # Add a grid for better readability ax.grid(True, linestyle='--', alpha=0.7) # Add a source note plt.figtext(0.5, 0.01, 'Source: SEC EDGAR via edgartools', ha='center', fontsize=9) # Improve layout plt.tight_layout(rect=[0, 0.03, 1, 0.97]) return fig 2. Investment Fund Research Problem: Need to analyze fund holdings and compare share classes. from edgar import find # Find a fund by ticker fund = find(\"VFIAX\") # Vanguard 500 Index Fund # Get the fund's structure classes = fund.get_classes() print(f\"Fund has {len(classes)} share classes\") # Get the latest portfolio holdings portfolio = fund.get_portfolio() # Show top 10 holdings by value top_holdings = portfolio.sort_values('value', ascending=False).head(10) top_holdings","title":"User Journeys"},{"location":"examples/#solve-real-problems-with-edgartools","text":"This document showcases common workflows and tasks that financial professionals, developers, and researchers can accomplish using EdgarTools. Each journey addresses a specific problem and provides a concise code example.","title":"Solve Real Problems with EdgarTools"},{"location":"examples/#1-company-financial-analysis","text":"Problem: Need to analyze a company's financial health across multiple periods. def get_income_dataframe(ticker:str): c = Company(ticker) filings = c.get_filings(form=\"10-K\").latest(5) xbs = XBRLS.from_filings(filings) income_statement = xbs.statements.income_statement() income_df = income_statement.to_dataframe() return income_df def plot_revenue(ticker:str): income_df = get_income_dataframe(ticker) # Extract financial metrics net_income = income_df[income_df.concept == \"us-gaap_NetIncomeLoss\"][income_statement.periods].iloc[0] gross_profit = income_df[income_df.concept == \"us-gaap_GrossProfit\"][income_statement.periods].iloc[0] revenue = income_df[income_df.label == \"Revenue\"][income_statement.periods].iloc[0] # Convert periods to fiscal years for better readability periods = [pd.to_datetime(period).strftime('FY%y') for period in income_statement.periods] # Reverse the order so most recent years are last (oldest to newest) periods = periods[::-1] revenue_values = revenue.values[::-1] gross_profit_values = gross_profit.values[::-1] net_income_values = net_income.values[::-1] # Create a DataFrame for plotting plot_data = pd.DataFrame({ 'Revenue': revenue_values, 'Gross Profit': gross_profit_values, 'Net Income': net_income_values }, index=periods) # Convert to billions for better readability plot_data = plot_data / 1e9 # Create the figure fig, ax = plt.subplots(figsize=(10, 6)) # Plot the data as lines with markers plot_data.plot(kind='line', marker='o', ax=ax, linewidth=2.5) # Format the y-axis to show billions with 1 decimal place ax.yaxis.set_major_formatter(mtick.FuncFormatter(lambda x, _: f'${x:.1f}B')) # Add labels and title ax.set_xlabel('Fiscal Year') ax.set_ylabel('Billions USD') ax.set_title(f'{c.name} ({ticker}) Financial Performance') # Add a grid for better readability ax.grid(True, linestyle='--', alpha=0.7) # Add a source note plt.figtext(0.5, 0.01, 'Source: SEC EDGAR via edgartools', ha='center', fontsize=9) # Improve layout plt.tight_layout(rect=[0, 0.03, 1, 0.97]) return fig","title":"1. Company Financial Analysis"},{"location":"examples/#2-investment-fund-research","text":"Problem: Need to analyze fund holdings and compare share classes. from edgar import find # Find a fund by ticker fund = find(\"VFIAX\") # Vanguard 500 Index Fund # Get the fund's structure classes = fund.get_classes() print(f\"Fund has {len(classes)} share classes\") # Get the latest portfolio holdings portfolio = fund.get_portfolio() # Show top 10 holdings by value top_holdings = portfolio.sort_values('value', ascending=False).head(10) top_holdings","title":"2. Investment Fund Research"},{"location":"filtering-filings/","text":"Filtering filings Filings can be filtered in many different ways like by form , date , CIK , ticker , and accession number . You also filter while getting filings using the get_filings function or after getting filings using the filter method. For the most part these approaches will give identical results, except that with get_filings you are filtering from all available filings in the SEC, while with filter you are reducing the nu,ber of filings in a Filings object. Filtering using parameters of get_filings You can filter using parameters of the get_filings function. Get filings by form To get filings of a specific form type like 10-K, you can use the form parameter. For example: filings = get_filings(form='10-K') The form can also be a list of forms. For example: filings = get_filings(form=['10-K', '10-Q']) By default the amendments parameter is set to True so that amended filings are included. You can set it to False to exclude amended filings. For example: filings = get_filings(form='10-K', amendments=False) Filtering by date You can filter filings by date using the filing_date parameter. For example: filings = get_filings(filing_date='2022-01-01') You can also filter by a range of dates. For example: filings = get_filings(filing_date='2022-01-01:2022-01-10') You can filter up to a date. For example: filings = get_filings(filing_date=':2022-01-10') as well as after a date. For example: filings = get_filings(filing_date='2022-01-10:') More filtering examples from edgar import get_filings # Get filings for 2021 filings_ = get_filings(2021) # Get filings for 2021 Q4 filings_ = get_filings(2021, 4) # Get filings for 2021 Q3 and Q4 filings_ = get_filings(2021, [3,4]) # Get filings for 2020 and 2021 filings_ = get_filings([2020, 2021]) # Get filings for Q4 of 2020 and 2021 filings_ = get_filings([2020, 2021], 4) # Get filings between 2010 and 2021 - does not include 2021 filings_ = get_filings(range(2010, 2021)) # Get filings for 2021 Q4 for form D filings_ = get_filings(2021, 4, form=\"D\") # Get filings for 2021 Q4 on \"2021-10-01\" filings_ = get_filings(2021, 4, filing_date=\"2021-10-01\") # Get filings for 2021 Q4 between \"2021-10-01\" and \"2021-10-10\" filings_ = get_filings(2021, 4, filing_date=\"2021-10-01:2021-10-10\") Filtering by CIK You can filter filings by CIK using the cik parameter to get all filings for a company. For example: filings = get_filings(cik='0000320193') Filtering by ticker You can filter filings by ticker using the ticker parameter. For example: filings = get_filings(ticker='AAPL') Note that this first does a lookup of the CIK for the ticker and then gets filings for the CIK. So if you know the CIK, it is better to use that directly. Filtering by exchange You can filter companies using the exchange parameter. filings = get_filings(exchange='NASDAQ') There are the following exchanges available: Exchange Nasdaq NYSE CBOE OTC Filtering using Filings.filter You can filter filings using the filter method after getting filings. This work mostly identically to filtering using get_filings . The difference is that filter reduces from an existing Filings object rather that the entire SEC. Example: filings().filter(form='10-K') def filter(self, *, form: Optional[Union[str, List[IntString]]] = None, amendments: bool = None, filing_date: Optional[str] = None, date: Optional[str] = None, cik: Union[IntString, List[IntString]] = None, exchange: Union[str, List[str], Exchange, List[Exchange]] = None, ticker: Union[str, List[str]] = None, accession_number: Union[str, List[str]] = None) -> Optional['Filings']: :param form: The form or list of forms to filter by :param amendments: Whether to include amendments to the forms e.g. include \"10-K/A\" :param filing_date: The filing date :param date: An alias for the filing date :param cik: The CIK or list of CIKs to filter by :param exchange: The exchange or list of exchanges to filter by :param ticker: The ticker or list of tickers to filter by :param accession_number: The accession number or list of accession numbers to filter by Using head , tail , and sample You can subset filings using the head and tail and sample methods. For example: filings = get_filings() filings.head(10) filings.tail(10) filings.sample(10)","title":"Filtering"},{"location":"filtering-filings/#filtering-filings","text":"Filings can be filtered in many different ways like by form , date , CIK , ticker , and accession number . You also filter while getting filings using the get_filings function or after getting filings using the filter method. For the most part these approaches will give identical results, except that with get_filings you are filtering from all available filings in the SEC, while with filter you are reducing the nu,ber of filings in a Filings object.","title":"Filtering filings"},{"location":"filtering-filings/#filtering-using-parameters-of-get_filings","text":"You can filter using parameters of the get_filings function.","title":"Filtering using parameters of get_filings"},{"location":"filtering-filings/#get-filings-by-form","text":"To get filings of a specific form type like 10-K, you can use the form parameter. For example: filings = get_filings(form='10-K') The form can also be a list of forms. For example: filings = get_filings(form=['10-K', '10-Q']) By default the amendments parameter is set to True so that amended filings are included. You can set it to False to exclude amended filings. For example: filings = get_filings(form='10-K', amendments=False)","title":"Get filings by form"},{"location":"filtering-filings/#filtering-by-date","text":"You can filter filings by date using the filing_date parameter. For example: filings = get_filings(filing_date='2022-01-01') You can also filter by a range of dates. For example: filings = get_filings(filing_date='2022-01-01:2022-01-10') You can filter up to a date. For example: filings = get_filings(filing_date=':2022-01-10') as well as after a date. For example: filings = get_filings(filing_date='2022-01-10:')","title":"Filtering by date"},{"location":"filtering-filings/#more-filtering-examples","text":"from edgar import get_filings # Get filings for 2021 filings_ = get_filings(2021) # Get filings for 2021 Q4 filings_ = get_filings(2021, 4) # Get filings for 2021 Q3 and Q4 filings_ = get_filings(2021, [3,4]) # Get filings for 2020 and 2021 filings_ = get_filings([2020, 2021]) # Get filings for Q4 of 2020 and 2021 filings_ = get_filings([2020, 2021], 4) # Get filings between 2010 and 2021 - does not include 2021 filings_ = get_filings(range(2010, 2021)) # Get filings for 2021 Q4 for form D filings_ = get_filings(2021, 4, form=\"D\") # Get filings for 2021 Q4 on \"2021-10-01\" filings_ = get_filings(2021, 4, filing_date=\"2021-10-01\") # Get filings for 2021 Q4 between \"2021-10-01\" and \"2021-10-10\" filings_ = get_filings(2021, 4, filing_date=\"2021-10-01:2021-10-10\")","title":"More filtering examples"},{"location":"filtering-filings/#filtering-by-cik","text":"You can filter filings by CIK using the cik parameter to get all filings for a company. For example: filings = get_filings(cik='0000320193')","title":"Filtering by CIK"},{"location":"filtering-filings/#filtering-by-ticker","text":"You can filter filings by ticker using the ticker parameter. For example: filings = get_filings(ticker='AAPL') Note that this first does a lookup of the CIK for the ticker and then gets filings for the CIK. So if you know the CIK, it is better to use that directly.","title":"Filtering by ticker"},{"location":"filtering-filings/#filtering-by-exchange","text":"You can filter companies using the exchange parameter. filings = get_filings(exchange='NASDAQ') There are the following exchanges available: Exchange Nasdaq NYSE CBOE OTC","title":"Filtering by exchange"},{"location":"filtering-filings/#filtering-using-filingsfilter","text":"You can filter filings using the filter method after getting filings. This work mostly identically to filtering using get_filings . The difference is that filter reduces from an existing Filings object rather that the entire SEC. Example: filings().filter(form='10-K') def filter(self, *, form: Optional[Union[str, List[IntString]]] = None, amendments: bool = None, filing_date: Optional[str] = None, date: Optional[str] = None, cik: Union[IntString, List[IntString]] = None, exchange: Union[str, List[str], Exchange, List[Exchange]] = None, ticker: Union[str, List[str]] = None, accession_number: Union[str, List[str]] = None) -> Optional['Filings']: :param form: The form or list of forms to filter by :param amendments: Whether to include amendments to the forms e.g. include \"10-K/A\" :param filing_date: The filing date :param date: An alias for the filing date :param cik: The CIK or list of CIKs to filter by :param exchange: The exchange or list of exchanges to filter by :param ticker: The ticker or list of tickers to filter by :param accession_number: The accession number or list of accession numbers to filter by","title":"Filtering using Filings.filter"},{"location":"filtering-filings/#using-head-tail-and-sample","text":"You can subset filings using the head and tail and sample methods. For example: filings = get_filings() filings.head(10) filings.tail(10) filings.sample(10)","title":"Using head, tail, and sample"},{"location":"insider-filings/","text":"Insider Filings Insider filings are reports filed by company insiders (such as officers, directors, and employees) when they buy or sell shares in their own companies. There are several types of insider filings that investors should be aware of: Form 3 : Filed by insiders to report their initial ownership of company stock - typically filed when an insider joins a company or becomes an officer or director. Form 4 : Filed to report any changes in ownership of company stock - typically filed when an insider buys or sells company stock. Form 5 : Includes any transactions that were not reported on Form 4 - typically filed at the end of the fiscal year. Getting Insider Filings You can access insider filings using the get_filings method of the Company class. c = Company(\"VRTX\") filings = c.get_filings(form=[3,4,5]) You can use either the string or numeric value for the form e.g. \"3\" or 3. filings = c.get_filings(form=4) If you are more interested in insider filings non-specific to a particular company, you can use the get_insider_filings method of the Filing class. filings = get_filings(form=[3,4,5]) The Ownership data object The Ownership object is a data object that represents the basic information contained in an insider filing. It is created by parsing the XML attachment with the data about the insider transactions in the filing. The Ownership is subclassed into Form3 , Form4 , and Form5 objects that contain additional information specific to the type of filing. So if you have a Form 3 filing you can convert the Ownership object to a Form3 object to get the additional information. form3 = filing.obj() Converting Ownership to a dataframe You can convert the Ownership object to a pandas dataframe using the to_dataframe() method. df = form4.to_dataframe() By default this will show each of the trades made in that filing. If you want to see the aggregated summary of the trades you can set detailed=False df = form4.to_dataframe(detailed=False) By default the dataframe will include metadata about the filing. If you want to exclude the metadata you can set include_metadata=False df = form4.to_dataframe(include_metadata=False) The specifics of the data in the dataframe will depend on the type of filing and the information contained in the filing. Form 3 - Initial Beneficial Ownership The Form3 data object is created from a form 3 filing as follows form3 = filing.obj() Form 4 - Changes in Beneficial Ownership In November 2020 Bruce Sachs, an independent director of Vertex Pharmaceuticals, filed a Form 4 to report the purchase of 15,000 shares of Vertex Pharmaceuticals (VRTX) at an average price of $217.36 per share. The filing object shows basic information but none of the details of the transaction. To get the details of the transaction you can use the obj() method to convert the filing to a Form4 object. form4 = filing.obj() The form 4 shows the individual transactions that make up the total transaction. In this case, the total transaction was the purchase of 15,000 shares of Vertex Pharmaceuticals. Additional information about the transaction can be found in the TransactionSummary object. ownership_summary = form4.get_ownership_summary() Form 5 - Annual Changes in Beneficial Ownership Form 5 filings are essentially the same as Form 4 filings but are filed at the end of the fiscal year to report any transactions that were not reported on Form 4. So the data in a Form 5 filing will be similar to that in a Form 4 filing. Ownership Summary The Ownership object has a get_ownership_summary() method that returns either an InitialOwnershipSummary for Form 3 filings or a TransactionSummary object for Forms 4 and 5. These object contain more specific details about the ownership filing. ownership_summary = form4.get_ownership_summary() Initial Ownership Summary The InitialOwnershipSummary object contains the following fields: total_shares - the total number of shares owned by the insider has_derivatives - a boolean indicating whether the insider owns any derivatives no_securities - a boolean indicating whether the insider owns any securities holdings : List[SecurityHolding] - a list of SecurityHolding objects representing the insider's holdings The SecurityHolding object is defined as follows: @dataclass class SecurityHolding: \"\"\"Represents a security holding (for Form 3)\"\"\" security_type: str # \"non-derivative\" or \"derivative\" security_title: str shares: int direct_ownership: bool ownership_nature: str = \"\" underlying_security: str = \"\" underlying_shares: int = 0 exercise_price: Optional[float] = None exercise_date: str = \"\" expiration_date: str = \"\" SecurityHolding also has these properties ownership_description - a human-readable description of the type of ownership \"Direct/Indirect\" is_derivative - a boolean indicating whether the holding is a derivative Transaction Summary The TransactionSummary object is defined as follows: @dataclass class TransactionActivity: \"\"\"Represents a specific transaction activity type\"\"\" transaction_type: str code: str shares: Any = 0 # Handle footnote references value: Any = 0 price_per_share: Any = None # Add explicit price per share field description: str = \"\" It also has these properties as a convenience in case any of the expected numeric values are not in fact numeric. shares_numeric - the number of shares involved in the transaction value_numeric - the value of the transaction price_numeric - the price per share of the transaction","title":"Insider Filings"},{"location":"insider-filings/#insider-filings","text":"Insider filings are reports filed by company insiders (such as officers, directors, and employees) when they buy or sell shares in their own companies. There are several types of insider filings that investors should be aware of: Form 3 : Filed by insiders to report their initial ownership of company stock - typically filed when an insider joins a company or becomes an officer or director. Form 4 : Filed to report any changes in ownership of company stock - typically filed when an insider buys or sells company stock. Form 5 : Includes any transactions that were not reported on Form 4 - typically filed at the end of the fiscal year.","title":"Insider Filings"},{"location":"insider-filings/#getting-insider-filings","text":"You can access insider filings using the get_filings method of the Company class. c = Company(\"VRTX\") filings = c.get_filings(form=[3,4,5]) You can use either the string or numeric value for the form e.g. \"3\" or 3. filings = c.get_filings(form=4) If you are more interested in insider filings non-specific to a particular company, you can use the get_insider_filings method of the Filing class. filings = get_filings(form=[3,4,5])","title":"Getting Insider Filings"},{"location":"insider-filings/#the-ownership-data-object","text":"The Ownership object is a data object that represents the basic information contained in an insider filing. It is created by parsing the XML attachment with the data about the insider transactions in the filing. The Ownership is subclassed into Form3 , Form4 , and Form5 objects that contain additional information specific to the type of filing. So if you have a Form 3 filing you can convert the Ownership object to a Form3 object to get the additional information. form3 = filing.obj()","title":"The Ownership data object"},{"location":"insider-filings/#converting-ownership-to-a-dataframe","text":"You can convert the Ownership object to a pandas dataframe using the to_dataframe() method. df = form4.to_dataframe() By default this will show each of the trades made in that filing. If you want to see the aggregated summary of the trades you can set detailed=False df = form4.to_dataframe(detailed=False) By default the dataframe will include metadata about the filing. If you want to exclude the metadata you can set include_metadata=False df = form4.to_dataframe(include_metadata=False) The specifics of the data in the dataframe will depend on the type of filing and the information contained in the filing.","title":"Converting Ownership to a dataframe"},{"location":"insider-filings/#form-3-initial-beneficial-ownership","text":"The Form3 data object is created from a form 3 filing as follows form3 = filing.obj()","title":"Form 3 - Initial Beneficial Ownership"},{"location":"insider-filings/#form-4-changes-in-beneficial-ownership","text":"In November 2020 Bruce Sachs, an independent director of Vertex Pharmaceuticals, filed a Form 4 to report the purchase of 15,000 shares of Vertex Pharmaceuticals (VRTX) at an average price of $217.36 per share. The filing object shows basic information but none of the details of the transaction. To get the details of the transaction you can use the obj() method to convert the filing to a Form4 object. form4 = filing.obj() The form 4 shows the individual transactions that make up the total transaction. In this case, the total transaction was the purchase of 15,000 shares of Vertex Pharmaceuticals. Additional information about the transaction can be found in the TransactionSummary object. ownership_summary = form4.get_ownership_summary()","title":"Form 4 - Changes in Beneficial Ownership"},{"location":"insider-filings/#form-5-annual-changes-in-beneficial-ownership","text":"Form 5 filings are essentially the same as Form 4 filings but are filed at the end of the fiscal year to report any transactions that were not reported on Form 4. So the data in a Form 5 filing will be similar to that in a Form 4 filing.","title":"Form 5 - Annual Changes in Beneficial Ownership"},{"location":"insider-filings/#ownership-summary","text":"The Ownership object has a get_ownership_summary() method that returns either an InitialOwnershipSummary for Form 3 filings or a TransactionSummary object for Forms 4 and 5. These object contain more specific details about the ownership filing. ownership_summary = form4.get_ownership_summary()","title":"Ownership Summary"},{"location":"insider-filings/#initial-ownership-summary","text":"The InitialOwnershipSummary object contains the following fields: total_shares - the total number of shares owned by the insider has_derivatives - a boolean indicating whether the insider owns any derivatives no_securities - a boolean indicating whether the insider owns any securities holdings : List[SecurityHolding] - a list of SecurityHolding objects representing the insider's holdings The SecurityHolding object is defined as follows: @dataclass class SecurityHolding: \"\"\"Represents a security holding (for Form 3)\"\"\" security_type: str # \"non-derivative\" or \"derivative\" security_title: str shares: int direct_ownership: bool ownership_nature: str = \"\" underlying_security: str = \"\" underlying_shares: int = 0 exercise_price: Optional[float] = None exercise_date: str = \"\" expiration_date: str = \"\" SecurityHolding also has these properties ownership_description - a human-readable description of the type of ownership \"Direct/Indirect\" is_derivative - a boolean indicating whether the holding is a derivative","title":"Initial Ownership Summary"},{"location":"insider-filings/#transaction-summary","text":"The TransactionSummary object is defined as follows: @dataclass class TransactionActivity: \"\"\"Represents a specific transaction activity type\"\"\" transaction_type: str code: str shares: Any = 0 # Handle footnote references value: Any = 0 price_per_share: Any = None # Add explicit price per share field description: str = \"\" It also has these properties as a convenience in case any of the expected numeric values are not in fact numeric. shares_numeric - the number of shares involved in the transaction value_numeric - the value of the transaction price_numeric - the price per share of the transaction","title":"Transaction Summary"},{"location":"local-data/","text":"Downloading to Local Storage When you use edgartools to get Company, or the html content of a filing, this usually results in one of more requests to the SEC. However, you can download data in bulk to local storage to minimize these requests and speed up processing. This includes the following data Data Descriptionn Company Submissions Company metadata, their 1000 most recent filings Company Facts Company facts Filing Attachments Filing attachments Reference data Reference data like company and mutual fund tickers, exchanges etc Local Data Directory The local data directory is the directory where the data is stored. The default directory is <USER_HOME>/.edgar You can change this directory by setting the EDGAR_LOCAL_DATA_DIR environment variable. export EDGAR_LOCAL_DATA_DIR=\"/path/to/local/data\" Using local storage By default local storage is not used and the library will access the data from the SEC website. To use local storage you have to Download data using download_edgar_data() Turn on local storage using the environment variable EDGAR_USE_LOCAL_DATA or by calling use_local_storage() Downloading data to local storage You can download data to local storage by calling the download_edgar_data() function. The function takes the following parameters so you have the option to download only the data you need. def download_edgar_data(submissions: bool = True, facts: bool = True, reference: bool = True): Downloading Complete Filings You can download filings to local storage by calling the download_filings() function. This will download for each filing a complete SGML text file that contains all the attachments for that filing. These will be placed in the directory EDGAR_LOCAL_DATA_DIR/filings/YYYYMMDD . If local storage is enabled, edgartools will first check if the filing is available in local storage before making a request to the SEC. This will speed up processing and for the most part calls like html() and text() will behave transparently. Note that there are some differences between local attachments and attachments when doownloaded from the SEC. Downloading by dates The download_filings(filing_date) function accepts a filing date that can be a single date or a range of dates. The date format must be YYYY-MM-DD or YYYY-MM-DD:YYYY-MM-DD . You can also use open ended ranges like YYYY-MM-DD: or :YYYY-MM-DD . Note that downloading filing attachment files can take a long time so be prepared when downloading for a range of dates. Accessing the downloaded filings When you call filing.attachments on a locally downloaded filing, you will have access to the attachments that were downloaded. If you want to have each file independently you can use attachments.download() . def download(self, path: Union[str, Path], archive: bool = False): \"\"\" Download all the attachments to a specified path. If the path is a directory, the file is saved with its original name in that directory. If the path is a file, the file is saved with the given path name. If archive is True, the attachments are saved in a zip file. path: str or Path - The path to save the attachments archive: bool (default False) - If True, save the attachments in a zip file \"\"\"","title":"Local Storage"},{"location":"local-data/#downloading-to-local-storage","text":"When you use edgartools to get Company, or the html content of a filing, this usually results in one of more requests to the SEC. However, you can download data in bulk to local storage to minimize these requests and speed up processing. This includes the following data Data Descriptionn Company Submissions Company metadata, their 1000 most recent filings Company Facts Company facts Filing Attachments Filing attachments Reference data Reference data like company and mutual fund tickers, exchanges etc","title":"Downloading to Local Storage"},{"location":"local-data/#local-data-directory","text":"The local data directory is the directory where the data is stored. The default directory is <USER_HOME>/.edgar You can change this directory by setting the EDGAR_LOCAL_DATA_DIR environment variable. export EDGAR_LOCAL_DATA_DIR=\"/path/to/local/data\"","title":"Local Data Directory"},{"location":"local-data/#using-local-storage","text":"By default local storage is not used and the library will access the data from the SEC website. To use local storage you have to Download data using download_edgar_data() Turn on local storage using the environment variable EDGAR_USE_LOCAL_DATA or by calling use_local_storage()","title":"Using local storage"},{"location":"local-data/#downloading-data-to-local-storage","text":"You can download data to local storage by calling the download_edgar_data() function. The function takes the following parameters so you have the option to download only the data you need. def download_edgar_data(submissions: bool = True, facts: bool = True, reference: bool = True):","title":"Downloading data to local storage"},{"location":"local-data/#downloading-complete-filings","text":"You can download filings to local storage by calling the download_filings() function. This will download for each filing a complete SGML text file that contains all the attachments for that filing. These will be placed in the directory EDGAR_LOCAL_DATA_DIR/filings/YYYYMMDD . If local storage is enabled, edgartools will first check if the filing is available in local storage before making a request to the SEC. This will speed up processing and for the most part calls like html() and text() will behave transparently. Note that there are some differences between local attachments and attachments when doownloaded from the SEC.","title":"Downloading Complete Filings"},{"location":"local-data/#downloading-by-dates","text":"The download_filings(filing_date) function accepts a filing date that can be a single date or a range of dates. The date format must be YYYY-MM-DD or YYYY-MM-DD:YYYY-MM-DD . You can also use open ended ranges like YYYY-MM-DD: or :YYYY-MM-DD . Note that downloading filing attachment files can take a long time so be prepared when downloading for a range of dates.","title":"Downloading by dates"},{"location":"local-data/#accessing-the-downloaded-filings","text":"When you call filing.attachments on a locally downloaded filing, you will have access to the attachments that were downloaded. If you want to have each file independently you can use attachments.download() . def download(self, path: Union[str, Path], archive: bool = False): \"\"\" Download all the attachments to a specified path. If the path is a directory, the file is saved with its original name in that directory. If the path is a file, the file is saved with the given path name. If archive is True, the attachments are saved in a zip file. path: str or Path - The path to save the attachments archive: bool (default False) - If True, save the attachments in a zip file \"\"\"","title":"Accessing the downloaded filings"},{"location":"navigating-filings/","text":"Navigating Filings Paginating filings The Filings object is a container for a list of filings. The list of filings can be large but by default you can only see the first page of filings. To change the page, you can paginate filings using the next and prev methods. For example: filings = get_filings() filings.next() filings.previous() Looping through filings You can loop through filings using the for loop. For example: filings = get_filings() for filing in filings: # Do something with the filing Getting Related Filings Filings can be related to other filings using the file number. In some cases this relationship can be meaningful, as in they represent a group of filings for a specific securities offering. The link between the filing is via the file_number attribute of the filing, which is an identifier that the SEC uses to group filings. You can get related filings using the get_related_filings method. For example: filing = get_filing('0000320193-22-000002') filings = filing.related_filings()","title":"Navigating Filings"},{"location":"navigating-filings/#navigating-filings","text":"","title":"Navigating Filings"},{"location":"navigating-filings/#paginating-filings","text":"The Filings object is a container for a list of filings. The list of filings can be large but by default you can only see the first page of filings. To change the page, you can paginate filings using the next and prev methods. For example: filings = get_filings() filings.next() filings.previous()","title":"Paginating filings"},{"location":"navigating-filings/#looping-through-filings","text":"You can loop through filings using the for loop. For example: filings = get_filings() for filing in filings: # Do something with the filing","title":"Looping through filings"},{"location":"navigating-filings/#getting-related-filings","text":"Filings can be related to other filings using the file number. In some cases this relationship can be meaningful, as in they represent a group of filings for a specific securities offering. The link between the filing is via the file_number attribute of the filing, which is an identifier that the SEC uses to group filings. You can get related filings using the get_related_filings method. For example: filing = get_filing('0000320193-22-000002') filings = filing.related_filings()","title":"Getting Related Filings"},{"location":"ownership/","text":"Ownership Documents Ownership documents are SEC forms that contain information about ownership of securities. Ownership Forms Form Description 3 Initial statement of beneficial ownership of securities 4 Statement of changes of beneficial ownership of securities 5 Annual statement of changes in beneficial ownership of securities The module edgar.ownership module parses XML into an OwnershipDocument instance, containing data about transactions and holdings. Getting Ownership Documents get a form 3 , 4 , or 5 filing get the xml document call OwnershipDocument.from_xml() from edgar import CompanyData from edgar.ownership import Ownership # Get Snowflake company = CompanyData.for_ticker(\"SNOW\") # Get Form 4 filings for Snowflake filings = company.get_filings(form=\"4\") # Get the first filing filing = filings[0] # Get the filing xml xml = filing.xml() # Now get the OwnershipDocument ownership = Ownership.from_xml(xml) Derivative Table This contains data on derivative holdings and transactions. To access it call ownership_document.derivatives . Derivative Holdings To access derivative transactions use ownership.derivatives.holdings Derivative Transactions To access derivative transactions use ownership.derivatives.transactions You can access individual transaction using the [] notation. ownership.derivative_table.transactions[0] Non Derivative Table This contains data on non-derivative holdings and transactions. To access it call ownership_document.non_ derivatives . Non Derivative Holdings To access derivative holdings use ownership.non_derivatives.holdings You can access individual holdings using the [] notation. holding = ownership.non_derivative_table.holdings[0] holding Non Derivative Transactions To access derivative transactions use ownership.non_derivatives.transactions You can access individual transactions using the [] notation. transaction = ownership.non_derivative_table.transactions[0] transaction","title":"Ownership Documents"},{"location":"ownership/#ownership-documents","text":"Ownership documents are SEC forms that contain information about ownership of securities.","title":"Ownership Documents"},{"location":"ownership/#ownership-forms","text":"Form Description 3 Initial statement of beneficial ownership of securities 4 Statement of changes of beneficial ownership of securities 5 Annual statement of changes in beneficial ownership of securities The module edgar.ownership module parses XML into an OwnershipDocument instance, containing data about transactions and holdings.","title":"Ownership Forms"},{"location":"ownership/#getting-ownership-documents","text":"get a form 3 , 4 , or 5 filing get the xml document call OwnershipDocument.from_xml() from edgar import CompanyData from edgar.ownership import Ownership # Get Snowflake company = CompanyData.for_ticker(\"SNOW\") # Get Form 4 filings for Snowflake filings = company.get_filings(form=\"4\") # Get the first filing filing = filings[0] # Get the filing xml xml = filing.xml() # Now get the OwnershipDocument ownership = Ownership.from_xml(xml)","title":"Getting Ownership Documents"},{"location":"ownership/#derivative-table","text":"This contains data on derivative holdings and transactions. To access it call ownership_document.derivatives .","title":"Derivative Table"},{"location":"ownership/#derivative-holdings","text":"To access derivative transactions use ownership.derivatives.holdings","title":"Derivative Holdings"},{"location":"ownership/#derivative-transactions","text":"To access derivative transactions use ownership.derivatives.transactions You can access individual transaction using the [] notation. ownership.derivative_table.transactions[0]","title":"Derivative Transactions"},{"location":"ownership/#non-derivative-table","text":"This contains data on non-derivative holdings and transactions. To access it call ownership_document.non_ derivatives .","title":"Non Derivative Table"},{"location":"ownership/#non-derivative-holdings","text":"To access derivative holdings use ownership.non_derivatives.holdings You can access individual holdings using the [] notation. holding = ownership.non_derivative_table.holdings[0] holding","title":"Non Derivative Holdings"},{"location":"ownership/#non-derivative-transactions","text":"To access derivative transactions use ownership.non_derivatives.transactions You can access individual transactions using the [] notation. transaction = ownership.non_derivative_table.transactions[0] transaction","title":"Non Derivative Transactions"},{"location":"parsing-filing-data/","text":"Parsing Filing Data An SEC filing represents information a company wishes to make public. The information is sometimes contained in data files attached to the filing, such as XBRL, XML or JSON. In edgartools each Filing has a .obj() function that converts the filing to a parsed version of the data file. For example, the following code converts the filing for the 10-K for Apple Inc. to a TenK object containing the data from the filing: from edgar import get_filings filings = get_filings(form=\"10-K\") filing = filings[0] tenk = filing.obj() Under the hood, the .obj() function gets the data file for the filing, which is usually the filing's XML, parses it, and converts it to the approaptate data object. If a filing has no corresponding data object, the .obj() function returns None Filing types with data objects The following table lists the filing types that have data objects: Filing type Data object Description 10-K TenK Annual report 10-Q TenQ Quarterly report 8-K EightK Current report 144 Form144 Insider trading report 3,4,5 Ownership Insider trading report D Effect Effect filing for the Form D NPORT NPORT Investment company report 13F-HR ThirteenF Institutional investment manager's report Any other filing with XBRL XbrlFiling XBRL filing object with the data Ownership Documents Ownership documents are SEC forms that contain information about ownership of securities. Ownership Forms Form Description 3 Initial statement of beneficial ownership of securities 4 Statement of changes of beneficial ownership of securities 5 Annual statement of changes in beneficial ownership of securities The module edgar.ownership module parses XML into an OwnershipDocument instance, containing data about transactions and holdings. Getting Ownership Documents get a form 3 , 4 , or 5 filing get the xml document call OwnershipDocument.from_xml() from edgar import CompanyData from edgar.ownership import Ownership # Get Snowflake company = CompanyData.for_ticker(\"SNOW\") # Get Form 4 filings for Snowflake filings = company.get_filings(form=\"4\") # Get the first filing filing = filings[0] # Get the filing xml xml = filing.xml() # Now get the OwnershipDocument ownership = Ownership.from_xml(xml) Derivative Table This contains data on derivative holdings and transactions. To access it call ownership_document.derivatives . Derivative Holdings To access derivative transactions use ownership.derivatives.holdings Derivative Transactions To access derivative transactions use ownership.derivatives.transactions You can access individual transaction using the [] notation. ownership.derivative_table.transactions[0] Non Derivative Table This contains data on non-derivative holdings and transactions. To access it call ownership_document.non_ derivatives . Non Derivative Holdings To access derivative holdings use ownership.non_derivatives.holdings You can access individual holdings using the [] notation. holding = ownership.non_derivative_table.holdings[0] holding Non Derivative Transactions To access derivative transactions use ownership.non_derivatives.transactions You can access individual transactions using the [] notation. transaction = ownership.non_derivative_table.transactions[0] transaction","title":"Parsing Filing Data"},{"location":"parsing-filing-data/#parsing-filing-data","text":"An SEC filing represents information a company wishes to make public. The information is sometimes contained in data files attached to the filing, such as XBRL, XML or JSON. In edgartools each Filing has a .obj() function that converts the filing to a parsed version of the data file. For example, the following code converts the filing for the 10-K for Apple Inc. to a TenK object containing the data from the filing: from edgar import get_filings filings = get_filings(form=\"10-K\") filing = filings[0] tenk = filing.obj() Under the hood, the .obj() function gets the data file for the filing, which is usually the filing's XML, parses it, and converts it to the approaptate data object. If a filing has no corresponding data object, the .obj() function returns None","title":"Parsing Filing Data"},{"location":"parsing-filing-data/#filing-types-with-data-objects","text":"The following table lists the filing types that have data objects: Filing type Data object Description 10-K TenK Annual report 10-Q TenQ Quarterly report 8-K EightK Current report 144 Form144 Insider trading report 3,4,5 Ownership Insider trading report D Effect Effect filing for the Form D NPORT NPORT Investment company report 13F-HR ThirteenF Institutional investment manager's report Any other filing with XBRL XbrlFiling XBRL filing object with the data","title":"Filing types with data objects"},{"location":"parsing-filing-data/#ownership-documents","text":"Ownership documents are SEC forms that contain information about ownership of securities.","title":"Ownership Documents"},{"location":"parsing-filing-data/#ownership-forms","text":"Form Description 3 Initial statement of beneficial ownership of securities 4 Statement of changes of beneficial ownership of securities 5 Annual statement of changes in beneficial ownership of securities The module edgar.ownership module parses XML into an OwnershipDocument instance, containing data about transactions and holdings.","title":"Ownership Forms"},{"location":"parsing-filing-data/#getting-ownership-documents","text":"get a form 3 , 4 , or 5 filing get the xml document call OwnershipDocument.from_xml() from edgar import CompanyData from edgar.ownership import Ownership # Get Snowflake company = CompanyData.for_ticker(\"SNOW\") # Get Form 4 filings for Snowflake filings = company.get_filings(form=\"4\") # Get the first filing filing = filings[0] # Get the filing xml xml = filing.xml() # Now get the OwnershipDocument ownership = Ownership.from_xml(xml)","title":"Getting Ownership Documents"},{"location":"parsing-filing-data/#derivative-table","text":"This contains data on derivative holdings and transactions. To access it call ownership_document.derivatives .","title":"Derivative Table"},{"location":"parsing-filing-data/#derivative-holdings","text":"To access derivative transactions use ownership.derivatives.holdings","title":"Derivative Holdings"},{"location":"parsing-filing-data/#derivative-transactions","text":"To access derivative transactions use ownership.derivatives.transactions You can access individual transaction using the [] notation. ownership.derivative_table.transactions[0]","title":"Derivative Transactions"},{"location":"parsing-filing-data/#non-derivative-table","text":"This contains data on non-derivative holdings and transactions. To access it call ownership_document.non_ derivatives .","title":"Non Derivative Table"},{"location":"parsing-filing-data/#non-derivative-holdings","text":"To access derivative holdings use ownership.non_derivatives.holdings You can access individual holdings using the [] notation. holding = ownership.non_derivative_table.holdings[0] holding","title":"Non Derivative Holdings"},{"location":"parsing-filing-data/#non-derivative-transactions","text":"To access derivative transactions use ownership.non_derivatives.transactions You can access individual transactions using the [] notation. transaction = ownership.non_derivative_table.transactions[0] transaction","title":"Non Derivative Transactions"},{"location":"polygon-api/","text":"Polygon API Integration The Polygon API integration provides functionality to fetch stock market data from Polygon.io, including AAPL stock prices for the last 7 days (or any custom period). Setup To use the Polygon API integration, you need to: Set the POLYGON_API_KEY environment variable with your Polygon API key: export POLYGON_API_KEY=\"your_api_key_here\" Usage Fetch AAPL Prices (Last 7 Days) from edgar import fetch_aapl_last_7_days # Fetch AAPL prices for the last 7 days state = fetch_aapl_last_7_days() print(state['prices']) # List of price data print(state['timestamp']) # When the data was fetched Fetch Any Stock Prices from edgar import fetch_aapl_prices # Fetch MSFT prices for the last 30 days state = fetch_aapl_prices(ticker='MSFT', days=30) Get Current Prices State from edgar import get_prices_state # Load the current prices state from file state = get_prices_state() # Access the data for price_data in state['prices']: print(f\"{price_data['date']}: Close=${price_data['close']}, Volume={price_data['volume']}\") State File The fetched prices are automatically saved to data/prices_state.json with the following structure: { \"timestamp\": \"2024-01-01T12:00:00.000000\", \"prices\": [ { \"date\": \"2024-01-01\", \"close\": 150.25, \"volume\": 52000000 }, { \"date\": \"2024-01-02\", \"close\": 151.50, \"volume\": 48000000 } ], \"last_fetch_timestamp\": \"2024-01-02T12:00:00.000000\" } Error Handling All API errors are logged to ~/fetch_errors.log with timestamps. If the API is unavailable or the API key is missing, a PolygonAPIError exception is raised. from edgar import fetch_aapl_prices, PolygonAPIError try: state = fetch_aapl_prices() except PolygonAPIError as e: print(f\"Error: {e}\") API Functions fetch_aapl_last_7_days(api_key=None) Convenience function to fetch AAPL stock prices for the last 7 days. Parameters: - api_key (str, optional): Polygon API key. If not provided, uses POLYGON_API_KEY environment variable. Returns: - dict: State dictionary with timestamp, prices list, and last_fetch_timestamp Raises: - PolygonAPIError : If API call fails fetch_aapl_prices(ticker='AAPL', days=7, api_key=None) Fetch stock prices for the specified ticker and date range. Parameters: - ticker (str): Stock ticker symbol (default: 'AAPL') - days (int): Number of days to fetch (default: 7) - api_key (str, optional): Polygon API key. If not provided, uses POLYGON_API_KEY environment variable. Returns: - dict: State dictionary with timestamp, prices list, and last_fetch_timestamp Raises: - PolygonAPIError : If API call fails get_prices_state() Load the prices state from the state file. Returns: - dict: State dictionary with timestamp, prices list, and last_fetch_timestamp save_prices_state(state) Save the prices state to the state file. Parameters: - state (dict): Dictionary containing timestamp, prices, and last_fetch_timestamp Raises: - PolygonAPIError : If file write fails Testing Run the test suite for the Polygon API integration: pytest tests/test_polygon.py -v","title":"Polygon API Integration"},{"location":"polygon-api/#polygon-api-integration","text":"The Polygon API integration provides functionality to fetch stock market data from Polygon.io, including AAPL stock prices for the last 7 days (or any custom period).","title":"Polygon API Integration"},{"location":"polygon-api/#setup","text":"To use the Polygon API integration, you need to: Set the POLYGON_API_KEY environment variable with your Polygon API key: export POLYGON_API_KEY=\"your_api_key_here\"","title":"Setup"},{"location":"polygon-api/#usage","text":"","title":"Usage"},{"location":"polygon-api/#fetch-aapl-prices-last-7-days","text":"from edgar import fetch_aapl_last_7_days # Fetch AAPL prices for the last 7 days state = fetch_aapl_last_7_days() print(state['prices']) # List of price data print(state['timestamp']) # When the data was fetched","title":"Fetch AAPL Prices (Last 7 Days)"},{"location":"polygon-api/#fetch-any-stock-prices","text":"from edgar import fetch_aapl_prices # Fetch MSFT prices for the last 30 days state = fetch_aapl_prices(ticker='MSFT', days=30)","title":"Fetch Any Stock Prices"},{"location":"polygon-api/#get-current-prices-state","text":"from edgar import get_prices_state # Load the current prices state from file state = get_prices_state() # Access the data for price_data in state['prices']: print(f\"{price_data['date']}: Close=${price_data['close']}, Volume={price_data['volume']}\")","title":"Get Current Prices State"},{"location":"polygon-api/#state-file","text":"The fetched prices are automatically saved to data/prices_state.json with the following structure: { \"timestamp\": \"2024-01-01T12:00:00.000000\", \"prices\": [ { \"date\": \"2024-01-01\", \"close\": 150.25, \"volume\": 52000000 }, { \"date\": \"2024-01-02\", \"close\": 151.50, \"volume\": 48000000 } ], \"last_fetch_timestamp\": \"2024-01-02T12:00:00.000000\" }","title":"State File"},{"location":"polygon-api/#error-handling","text":"All API errors are logged to ~/fetch_errors.log with timestamps. If the API is unavailable or the API key is missing, a PolygonAPIError exception is raised. from edgar import fetch_aapl_prices, PolygonAPIError try: state = fetch_aapl_prices() except PolygonAPIError as e: print(f\"Error: {e}\")","title":"Error Handling"},{"location":"polygon-api/#api-functions","text":"","title":"API Functions"},{"location":"polygon-api/#fetch_aapl_last_7_daysapi_keynone","text":"Convenience function to fetch AAPL stock prices for the last 7 days. Parameters: - api_key (str, optional): Polygon API key. If not provided, uses POLYGON_API_KEY environment variable. Returns: - dict: State dictionary with timestamp, prices list, and last_fetch_timestamp Raises: - PolygonAPIError : If API call fails","title":"fetch_aapl_last_7_days(api_key=None)"},{"location":"polygon-api/#fetch_aapl_pricestickeraapl-days7-api_keynone","text":"Fetch stock prices for the specified ticker and date range. Parameters: - ticker (str): Stock ticker symbol (default: 'AAPL') - days (int): Number of days to fetch (default: 7) - api_key (str, optional): Polygon API key. If not provided, uses POLYGON_API_KEY environment variable. Returns: - dict: State dictionary with timestamp, prices list, and last_fetch_timestamp Raises: - PolygonAPIError : If API call fails","title":"fetch_aapl_prices(ticker='AAPL', days=7, api_key=None)"},{"location":"polygon-api/#get_prices_state","text":"Load the prices state from the state file. Returns: - dict: State dictionary with timestamp, prices list, and last_fetch_timestamp","title":"get_prices_state()"},{"location":"polygon-api/#save_prices_statestate","text":"Save the prices state to the state file. Parameters: - state (dict): Dictionary containing timestamp, prices, and last_fetch_timestamp Raises: - PolygonAPIError : If file write fails","title":"save_prices_state(state)"},{"location":"polygon-api/#testing","text":"Run the test suite for the Polygon API integration: pytest tests/test_polygon.py -v","title":"Testing"},{"location":"quick-guide/","text":"Quick Guide Code Set your EDGAR identity in Linux/Mac export EDGAR_IDENTITY=\"email@domain.com\" Set your EDGAR identity in Windows set EDGAR_IDENTITY=\"email@domain.com\" Set identity in Windows Powershell $env:EDGAR_IDENTITY=\"email@domain.com\" Set identity in Python set_identity(\"email@domain.com\") Importing the library from edgar import * Working with filings \ud83d\udcc1 \ud83d\udd0d Getting Filings Code \ud83d\udcc5 Get filings for the year to date filings = get_filings() \ud83d\udcca Get only XBRL filings filings = get_filings(index=\"xbrl\") \ud83d\udcc6 Get filings for a specific year filings = get_filings(2020) \ud83d\uddd3\ufe0f Get filings for a specific quarter filings = get_filings(2020, 1) \ud83d\udcda Get filings for multiple years filings = get_filings([2020, 2021]) \ud83d\udcc8 Get filings for a range of years filings = get_filings(year=range(2010, 2020)) \ud83d\udcc8 Get filings released just now filings = get_latest_filings() \ud83d\udcc4 Filtering Filings Code \ud83d\udcdd Filter by form type filings.filter(form=\"10-K\") \ud83d\udcd1 Filter by multiple forms filings.filter(form=[\"10-K\", \"10-Q\"]) \ud83d\udd04 Include form amendments filings.filter(form=\"10-K\", amendments=True) \ud83c\udfe2 Filter by CIK filings.filter(cik=\"0000320193\") \ud83c\udfd9\ufe0f Filter by multiple CIKs filings.filter(cik=[\"0000320193\", \"1018724\"]) \ud83c\udff7\ufe0f Filter by ticker filings.filter(ticker=\"AAPL\") \ud83c\udff7\ufe0f\ud83c\udff7\ufe0f Filter by multiple tickers filings.filter(ticker=[\"AAPL\", \"MSFT\"]) \ud83d\udcc5 Filter on a specific date filings.filter(date=\"2020-01-01\") \ud83d\udcc5\u2194\ufe0f\ud83d\udcc5 Filter between dates filings.filter(date=\"2020-01-01:2020-03-01\") \ud83d\udcc5\u2b05\ufe0f Filter before a date filings.filter(date=\":2020-03-01\") \ud83d\udcc5\u27a1\ufe0f Filter after a date filings.filter(date=\"2020-03-01:\") \ud83d\udd00 Combine multiple filters filings.filter(form=\"10-K\", date=\"2020-01-01:\", ticker=\"AAPL\") \ud83d\udcca Viewing and Manipulating Filings Code \u23ed\ufe0f Show the next page of filings filings.next() \u23ee\ufe0f Show the previous page of filings filings.previous() \ud83d\udd1d Get the first n filings filings.head(20) \ud83d\udd1a Get the last n filings filings.tail(20) \ud83d\udd52 Get the latest n filings by date filings.latest(20) \ud83c\udfb2 Get a random sample of filings filings.sample(20) \ud83d\udc3c Get filings as a pandas dataframe filings.to_pandas() Working with a filing \ud83d\udcc4 \ud83d\udd0d Accessing and viewing a Filing Code \ud83d\udccc Get a single filing filing = filings[3] \ud83d\udd22 Get a filing by accession number filing = get_by_accession_number(\"0000320193-20-34576\") \ud83c\udfe0 Get the filing homepage filing.homepage \ud83c\udf10 Open a filing in the browser filing.open() \ud83c\udfe0 Open homepage in the browser filing.homepage.open() \ud83d\udcbb View the filing in the terminal filing.view() \ud83d\udcca Extracting Filing Content Code \ud83c\udf10 Get the HTML of the filing filing.html() \ud83d\udcca Get the XBRL of the filing filing.xbrl() \ud83d\udcdd Get the filing as markdown filing.markdown() \ud83d\udcc4 Get the full submission text filing.full_text_submission() \ud83d\udd22 Get and parse filing data object filing.obj() \ud83d\udcd1 Get filing header filing.header \ud83d\udd0e Searching inside a Filing Code \ud83d\udd0d Search within the filing filing.search(\"query\") \ud83d\udd0d Search with regex filing.search(\"pattern\", regex=True) \ud83d\udcca Get filing sections filing.sections() \ud83d\udcce Working with Attachments Code \ud83d\udcc1 Get all filing attachments filing.attachments \ud83d\udcc4 Get a single attachment attachment = filing.attachments[0] \ud83c\udf10 Open attachment in browser attachment.open() \u2b07\ufe0f Download an attachment content = attachment.download() Working with a company Code Get a company by ticker company = Company(\"AAPL\") Get a company by CIK company = Company(\"0000320193\") Get company facts company.get_facts() Get company facts as a pandas dataframe company.get_facts().to_pandas() Get company filings company.get_filings() Get company filings by form company.get_filings(form=\"10-K\") Get the latest 10-Q company.latest(\"10-Q\") Get the last 5 10-Q's company.get_filings(form=\"10-Q\", 5) Get a company filing by accession_number company.get_filing(accession_number=\"0000320193-21-000139\") Get the company's financials company.financials Get the company's balance sheet company.financials.balance_sheet() Get the company's income statement company.financials.income_statement() Get the company's cash flow statement company.financials.cashflow_statement()","title":"Quick Guide"},{"location":"quick-guide/#quick-guide","text":"Code Set your EDGAR identity in Linux/Mac export EDGAR_IDENTITY=\"email@domain.com\" Set your EDGAR identity in Windows set EDGAR_IDENTITY=\"email@domain.com\" Set identity in Windows Powershell $env:EDGAR_IDENTITY=\"email@domain.com\" Set identity in Python set_identity(\"email@domain.com\") Importing the library from edgar import *","title":"Quick Guide"},{"location":"quick-guide/#working-with-filings","text":"","title":"Working with filings \ud83d\udcc1"},{"location":"quick-guide/#getting-filings","text":"Code \ud83d\udcc5 Get filings for the year to date filings = get_filings() \ud83d\udcca Get only XBRL filings filings = get_filings(index=\"xbrl\") \ud83d\udcc6 Get filings for a specific year filings = get_filings(2020) \ud83d\uddd3\ufe0f Get filings for a specific quarter filings = get_filings(2020, 1) \ud83d\udcda Get filings for multiple years filings = get_filings([2020, 2021]) \ud83d\udcc8 Get filings for a range of years filings = get_filings(year=range(2010, 2020)) \ud83d\udcc8 Get filings released just now filings = get_latest_filings()","title":"\ud83d\udd0d Getting Filings"},{"location":"quick-guide/#filtering-filings","text":"Code \ud83d\udcdd Filter by form type filings.filter(form=\"10-K\") \ud83d\udcd1 Filter by multiple forms filings.filter(form=[\"10-K\", \"10-Q\"]) \ud83d\udd04 Include form amendments filings.filter(form=\"10-K\", amendments=True) \ud83c\udfe2 Filter by CIK filings.filter(cik=\"0000320193\") \ud83c\udfd9\ufe0f Filter by multiple CIKs filings.filter(cik=[\"0000320193\", \"1018724\"]) \ud83c\udff7\ufe0f Filter by ticker filings.filter(ticker=\"AAPL\") \ud83c\udff7\ufe0f\ud83c\udff7\ufe0f Filter by multiple tickers filings.filter(ticker=[\"AAPL\", \"MSFT\"]) \ud83d\udcc5 Filter on a specific date filings.filter(date=\"2020-01-01\") \ud83d\udcc5\u2194\ufe0f\ud83d\udcc5 Filter between dates filings.filter(date=\"2020-01-01:2020-03-01\") \ud83d\udcc5\u2b05\ufe0f Filter before a date filings.filter(date=\":2020-03-01\") \ud83d\udcc5\u27a1\ufe0f Filter after a date filings.filter(date=\"2020-03-01:\") \ud83d\udd00 Combine multiple filters filings.filter(form=\"10-K\", date=\"2020-01-01:\", ticker=\"AAPL\")","title":"\ud83d\udcc4 Filtering Filings"},{"location":"quick-guide/#viewing-and-manipulating-filings","text":"Code \u23ed\ufe0f Show the next page of filings filings.next() \u23ee\ufe0f Show the previous page of filings filings.previous() \ud83d\udd1d Get the first n filings filings.head(20) \ud83d\udd1a Get the last n filings filings.tail(20) \ud83d\udd52 Get the latest n filings by date filings.latest(20) \ud83c\udfb2 Get a random sample of filings filings.sample(20) \ud83d\udc3c Get filings as a pandas dataframe filings.to_pandas()","title":"\ud83d\udcca Viewing and Manipulating Filings"},{"location":"quick-guide/#working-with-a-filing","text":"","title":"Working with a filing \ud83d\udcc4"},{"location":"quick-guide/#accessing-and-viewing-a-filing","text":"Code \ud83d\udccc Get a single filing filing = filings[3] \ud83d\udd22 Get a filing by accession number filing = get_by_accession_number(\"0000320193-20-34576\") \ud83c\udfe0 Get the filing homepage filing.homepage \ud83c\udf10 Open a filing in the browser filing.open() \ud83c\udfe0 Open homepage in the browser filing.homepage.open() \ud83d\udcbb View the filing in the terminal filing.view()","title":"\ud83d\udd0d Accessing and viewing a Filing"},{"location":"quick-guide/#extracting-filing-content","text":"Code \ud83c\udf10 Get the HTML of the filing filing.html() \ud83d\udcca Get the XBRL of the filing filing.xbrl() \ud83d\udcdd Get the filing as markdown filing.markdown() \ud83d\udcc4 Get the full submission text filing.full_text_submission() \ud83d\udd22 Get and parse filing data object filing.obj() \ud83d\udcd1 Get filing header filing.header","title":"\ud83d\udcca Extracting Filing Content"},{"location":"quick-guide/#searching-inside-a-filing","text":"Code \ud83d\udd0d Search within the filing filing.search(\"query\") \ud83d\udd0d Search with regex filing.search(\"pattern\", regex=True) \ud83d\udcca Get filing sections filing.sections()","title":"\ud83d\udd0e Searching inside a Filing"},{"location":"quick-guide/#working-with-attachments","text":"Code \ud83d\udcc1 Get all filing attachments filing.attachments \ud83d\udcc4 Get a single attachment attachment = filing.attachments[0] \ud83c\udf10 Open attachment in browser attachment.open() \u2b07\ufe0f Download an attachment content = attachment.download()","title":"\ud83d\udcce Working with Attachments"},{"location":"quick-guide/#working-with-a-company","text":"Code Get a company by ticker company = Company(\"AAPL\") Get a company by CIK company = Company(\"0000320193\") Get company facts company.get_facts() Get company facts as a pandas dataframe company.get_facts().to_pandas() Get company filings company.get_filings() Get company filings by form company.get_filings(form=\"10-K\") Get the latest 10-Q company.latest(\"10-Q\") Get the last 5 10-Q's company.get_filings(form=\"10-Q\", 5) Get a company filing by accession_number company.get_filing(accession_number=\"0000320193-21-000139\") Get the company's financials company.financials Get the company's balance sheet company.financials.balance_sheet() Get the company's income statement company.financials.income_statement() Get the company's cash flow statement company.financials.cashflow_statement()","title":"Working with a company"},{"location":"sgml/","text":"SGML The SEC EDGAR system uses a specialized subset of SGML (Standard Generalized Markup Language) for regulatory filings. While commonly referred to as SGML, it implements a simplified version with SEC-specific tags and structures. This format has been the backbone of SEC filings since the 1990s, chosen for its ability to maintain consistent document structure while supporting both structured data and free-form text. Understanding SGML Container Formats You might be familiar with SGML from having seeing the Full Text File (.txt) or the (.nc) formats in SEC filings. The SEC EDGAR system actually utilizes two distinct SGML container formats, each serving different purposes in the filing process: Complete Submission Text File (.txt) The .txt format contains the complete submission as received by EDGAR, including all documents, headers, and content. This is the primary public-facing format that preserves the exact submission. A typical .txt container begins with: <SEC-DOCUMENT>0000320193-24-000123.txt : 20241101 <SEC-HEADER>0000320193-24-000123.hdr.sgml : 20241101 <ACCEPTANCE-DATETIME>20241101060136 ACCESSION NUMBER: 0000320193-24-000123 The .txt container includes: - Full document content - SEC headers - Metadata - All exhibits and attachments - Processing timestamps Non-Public Complete File (.nc) The .nc format serves as a submission manifest or index file, containing metadata about the filing without the full content. This format is used for processing, validation, and internal SEC workflows. A typical .nc container starts with: <SUBMISSION> <ACCESSION-NUMBER>0002002260-24-000001 <TYPE>D <PUBLIC-DOCUMENT-COUNT>1 <ITEMS>06b <ITEMS>3C The .nc container tracks: - Submission type and status - Document counts - Reporting items - Cross-reference information - Processing instructions - Special handling requirements Understanding the SEC Processing Pipeline Understanding the relationship between these formats is crucial for processing SEC filings: Initial submission includes both formats .nc file is processed first for validation .txt file is processed for content extraction Both files are archived for record-keeping Public access is primarily to the .txt content This dual-format system enables the SEC to maintain separate processing pipelines for submission handling and public access while ensuring comprehensive record-keeping and validation. How edgartools uses SGML The library uses the SGML to get the attachments and important metadata about the filing. filing.attachments the library will get the SGML file and parse it to get the attachments. You will mostly work with the objects and attributes of the Filing class, rather than directly with the SGML file. @property def attachments(self): # Return all the attachments on the filing sgml_filing: FilingSGML = self.sgml() return sgml_filing.attachments The sgml() function will download the SGML file, or read from a file if using LocalStorage . The FilingSGML class The FilingSGML class is used to parse the SGML file. It has a few methods to get the attachments, and the text of the filing. Parsing SGML from a file or a URL The function from_source is used to create a FilingSGML object from a source. The source can be a string representing a file name or a URL, or it can be a Path sgml = FilingSGML.from_source(\"https://www.sec.gov/Archives/edgar/data/320193/000032019321000139/0000320193-21-000139.txt\") # OR sgml = FilingSGML.from_source(Path(\"path/to/0001398344-24-000491.nc\")) This will parse either SGML format and return a FilingSGML object. Getting the attachments The attachments property will return an Attachments class that contains the Attachment . attachments = sgml.attachments Getting the content of a file You can get the content of a file using the get_content method. sgml.get_content(\"EX-101.INS\") Getting html You can get the html for the filing using the html method. This will find the primary HTML document in the FilingSGML: attachments, find the html and return it. html = sgml.html() Getting xml You can get the xml for the filing using the xml method. This will find the primary XML document in the FilingSGML: attachments, find the xml and return it. This function will return None if no XML document is found. sgml.xml()","title":"SGML"},{"location":"sgml/#sgml","text":"The SEC EDGAR system uses a specialized subset of SGML (Standard Generalized Markup Language) for regulatory filings. While commonly referred to as SGML, it implements a simplified version with SEC-specific tags and structures. This format has been the backbone of SEC filings since the 1990s, chosen for its ability to maintain consistent document structure while supporting both structured data and free-form text.","title":"SGML"},{"location":"sgml/#understanding-sgml-container-formats","text":"You might be familiar with SGML from having seeing the Full Text File (.txt) or the (.nc) formats in SEC filings. The SEC EDGAR system actually utilizes two distinct SGML container formats, each serving different purposes in the filing process:","title":"Understanding SGML Container Formats"},{"location":"sgml/#complete-submission-text-file-txt","text":"The .txt format contains the complete submission as received by EDGAR, including all documents, headers, and content. This is the primary public-facing format that preserves the exact submission. A typical .txt container begins with: <SEC-DOCUMENT>0000320193-24-000123.txt : 20241101 <SEC-HEADER>0000320193-24-000123.hdr.sgml : 20241101 <ACCEPTANCE-DATETIME>20241101060136 ACCESSION NUMBER: 0000320193-24-000123 The .txt container includes: - Full document content - SEC headers - Metadata - All exhibits and attachments - Processing timestamps","title":"Complete Submission Text File (.txt)"},{"location":"sgml/#non-public-complete-file-nc","text":"The .nc format serves as a submission manifest or index file, containing metadata about the filing without the full content. This format is used for processing, validation, and internal SEC workflows. A typical .nc container starts with: <SUBMISSION> <ACCESSION-NUMBER>0002002260-24-000001 <TYPE>D <PUBLIC-DOCUMENT-COUNT>1 <ITEMS>06b <ITEMS>3C The .nc container tracks: - Submission type and status - Document counts - Reporting items - Cross-reference information - Processing instructions - Special handling requirements","title":"Non-Public Complete File (.nc)"},{"location":"sgml/#understanding-the-sec-processing-pipeline","text":"Understanding the relationship between these formats is crucial for processing SEC filings: Initial submission includes both formats .nc file is processed first for validation .txt file is processed for content extraction Both files are archived for record-keeping Public access is primarily to the .txt content This dual-format system enables the SEC to maintain separate processing pipelines for submission handling and public access while ensuring comprehensive record-keeping and validation.","title":"Understanding the SEC Processing Pipeline"},{"location":"sgml/#how-edgartools-uses-sgml","text":"The library uses the SGML to get the attachments and important metadata about the filing. filing.attachments the library will get the SGML file and parse it to get the attachments. You will mostly work with the objects and attributes of the Filing class, rather than directly with the SGML file. @property def attachments(self): # Return all the attachments on the filing sgml_filing: FilingSGML = self.sgml() return sgml_filing.attachments The sgml() function will download the SGML file, or read from a file if using LocalStorage .","title":"How edgartools uses SGML"},{"location":"sgml/#the-filingsgml-class","text":"The FilingSGML class is used to parse the SGML file. It has a few methods to get the attachments, and the text of the filing.","title":"The FilingSGML class"},{"location":"sgml/#parsing-sgml-from-a-file-or-a-url","text":"The function from_source is used to create a FilingSGML object from a source. The source can be a string representing a file name or a URL, or it can be a Path sgml = FilingSGML.from_source(\"https://www.sec.gov/Archives/edgar/data/320193/000032019321000139/0000320193-21-000139.txt\") # OR sgml = FilingSGML.from_source(Path(\"path/to/0001398344-24-000491.nc\")) This will parse either SGML format and return a FilingSGML object.","title":"Parsing SGML from a file or a URL"},{"location":"sgml/#getting-the-attachments","text":"The attachments property will return an Attachments class that contains the Attachment . attachments = sgml.attachments","title":"Getting the attachments"},{"location":"sgml/#getting-the-content-of-a-file","text":"You can get the content of a file using the get_content method. sgml.get_content(\"EX-101.INS\")","title":"Getting the content of a file"},{"location":"sgml/#getting-html","text":"You can get the html for the filing using the html method. This will find the primary HTML document in the FilingSGML: attachments, find the html and return it. html = sgml.html()","title":"Getting html"},{"location":"sgml/#getting-xml","text":"You can get the xml for the filing using the xml method. This will find the primary XML document in the FilingSGML: attachments, find the xml and return it. This function will return None if no XML document is found. sgml.xml()","title":"Getting xml"},{"location":"using-the-filings-api/","text":"Filings To get started import from edgar and use the get_filings function. from edgar import * filings = get_filings() This gets the list of filings for the current year and quarter into a Filings object. If you need a different date range you can specify a year or years and a quarter or quarters. These are valid ways to specify the date range or filter by form or by filing date. >>> filings = get_filings(2021) # Get filings for 2021 >>> filings = get_filings(2021, 4) # Get filings for 2021 Q4 >>> filings = get_filings(2021, [3,4]) # Get filings for 2021 Q3 and Q4 >>> filings = get_filings([2020, 2021]) # Get filings for 2020 and 2021 >>> filings = get_filings([2020, 2021], 4) # Get filings for Q4 of 2020 and 2021 >>> filings = get_filings(range(2010, 2021)) # Get filings between 2010 and 2021 - does not include 2021 >>> filings = get_filings(2021, 4, form=\"D\") # Get filings for 2021 Q4 for form D >>> filings = get_filings(2021, 4, filing_date=\"2021-10-01\") # Get filings for 2021 Q4 on \"2021-10-01\" >>> filings = get_filings(2021, 4, filing_date=\"2021-10-01:2021-10-10\") # Get filings for 2021 Q4 between # \"2021-10-01\" and \"2021-10-10\" Convert the filings to a pandas dataframe The filings data is stored in the Filings class as a pyarrow.Table . You can get the data as a pandas dataframe using to_pandas df = filings.to_pandas() Navigating filings The Filings object allows you to navigate through filings using filings.next() and filings.prev() . This shows you pages of the data - the page size is about 50. # To see the next page of data filings.next() # To see the previous page filings.previous() # To see the current page filings.current() Getting the latest filings You can get the latest n filings by filing_date from a filings using filings.latest() . If you provide the parameter n it will return the latest n filings. filing = filings.latest(n=5) filing If you omit this parameter, or set n=1 it will return a single `Filings object. filing = filings.latest() filing Filtering filings You can filter the filings object using te filter() function. This allows you to filter by filing date, or by form. Filtering filings by date To filter by filing date specify the filing date in YYYY-MM-DD format e.g. 2022-01-24 (Note the parameters date and filing_date are equivalent aliases for each other) filings.filter(date=\"2021-01-24\") # or filings.filter(filing_date=\"2021-01-24\") You can specify a filing date range using the colon filings.filter(date=\"2021-01-12:2021-02-28\") To filter by dates before a specified date use `:YYYY-MM-DD' filings.filter(date=\":2021-02-28\") To filter by dates after a specified date use `YYYY-MM-DD:' filings.filter(date=\"2021-02-28:\") Filtering filings by form You can filter filings by form using the form parameter. filings.filter(form=\"10-K\") To filter by form e.g. 10-K and include form amendments use amendments = True . filings.filter(form=\"10-K\", amendments=True) Getting a single filing You can get a single filing from the filings using the bracket operator [] , specifying the index of the filing. The index is the value displayed in the leftmost position in the filings table. For example, to get the 10-Q for Costco in the table above use filings[3] filing = filings[3] View the filing homepage You can view the filing homepage in the terminal using filing.homepage This gives you access to the FilingHomepage class that you can use to list all the documents and datafiles on the filing. filing.homepage Open a filing You can open the filing in your browser using filing.open() . This will work on environments with access to the browser, will probably not work on a remote server. filing.open() Open the Filing Homepage You can open the filing homepage in the browser using filing.homepage.open() . filing.homepage.open() View the filing as Markdown You can view the filing's HTML content as markdown in the console using view() . It works for all filing types but can be a little slow for filings with large HTML files filing.view() Get the filing's html You can get the html content of the filing using .html() filing.html() Get the filing's html as Markdown You can get the html content as markdown using .markdown() filing.markdown() Working with XBRL filings Some filings are in XBRL (eXtensible Business Markup Language) format. These are mainly the newer filings, as the SEC has started requiring this for newer filings. If a filing is in XBRL format then it opens up a lot more ways to get structured data about that specific filing and also about the company referred to in that filing. The Filing class has an xbrl function that will download, parse and structure the filing's XBRL document if one exists. If it does not exist, then filing.xbrl() will return None . The function filing.xbrl() returns a FilingXbrl instance, which wraps the data, and provides convenient ways of working with the xbrl data. filing_xbrl = filing.xbrl()","title":"Filings"},{"location":"using-the-filings-api/#filings","text":"To get started import from edgar and use the get_filings function. from edgar import * filings = get_filings() This gets the list of filings for the current year and quarter into a Filings object. If you need a different date range you can specify a year or years and a quarter or quarters. These are valid ways to specify the date range or filter by form or by filing date. >>> filings = get_filings(2021) # Get filings for 2021 >>> filings = get_filings(2021, 4) # Get filings for 2021 Q4 >>> filings = get_filings(2021, [3,4]) # Get filings for 2021 Q3 and Q4 >>> filings = get_filings([2020, 2021]) # Get filings for 2020 and 2021 >>> filings = get_filings([2020, 2021], 4) # Get filings for Q4 of 2020 and 2021 >>> filings = get_filings(range(2010, 2021)) # Get filings between 2010 and 2021 - does not include 2021 >>> filings = get_filings(2021, 4, form=\"D\") # Get filings for 2021 Q4 for form D >>> filings = get_filings(2021, 4, filing_date=\"2021-10-01\") # Get filings for 2021 Q4 on \"2021-10-01\" >>> filings = get_filings(2021, 4, filing_date=\"2021-10-01:2021-10-10\") # Get filings for 2021 Q4 between # \"2021-10-01\" and \"2021-10-10\"","title":"Filings"},{"location":"using-the-filings-api/#convert-the-filings-to-a-pandas-dataframe","text":"The filings data is stored in the Filings class as a pyarrow.Table . You can get the data as a pandas dataframe using to_pandas df = filings.to_pandas()","title":"Convert the filings to a pandas dataframe"},{"location":"using-the-filings-api/#navigating-filings","text":"The Filings object allows you to navigate through filings using filings.next() and filings.prev() . This shows you pages of the data - the page size is about 50. # To see the next page of data filings.next() # To see the previous page filings.previous() # To see the current page filings.current()","title":"Navigating filings"},{"location":"using-the-filings-api/#getting-the-latest-filings","text":"You can get the latest n filings by filing_date from a filings using filings.latest() . If you provide the parameter n it will return the latest n filings. filing = filings.latest(n=5) filing If you omit this parameter, or set n=1 it will return a single `Filings object. filing = filings.latest() filing","title":"Getting the latest filings"},{"location":"using-the-filings-api/#filtering-filings","text":"You can filter the filings object using te filter() function. This allows you to filter by filing date, or by form.","title":"Filtering filings"},{"location":"using-the-filings-api/#filtering-filings-by-date","text":"To filter by filing date specify the filing date in YYYY-MM-DD format e.g. 2022-01-24 (Note the parameters date and filing_date are equivalent aliases for each other) filings.filter(date=\"2021-01-24\") # or filings.filter(filing_date=\"2021-01-24\") You can specify a filing date range using the colon filings.filter(date=\"2021-01-12:2021-02-28\") To filter by dates before a specified date use `:YYYY-MM-DD' filings.filter(date=\":2021-02-28\") To filter by dates after a specified date use `YYYY-MM-DD:' filings.filter(date=\"2021-02-28:\")","title":"Filtering filings by date"},{"location":"using-the-filings-api/#filtering-filings-by-form","text":"You can filter filings by form using the form parameter. filings.filter(form=\"10-K\") To filter by form e.g. 10-K and include form amendments use amendments = True . filings.filter(form=\"10-K\", amendments=True)","title":"Filtering filings by form"},{"location":"using-the-filings-api/#getting-a-single-filing","text":"You can get a single filing from the filings using the bracket operator [] , specifying the index of the filing. The index is the value displayed in the leftmost position in the filings table. For example, to get the 10-Q for Costco in the table above use filings[3] filing = filings[3]","title":"Getting a single filing"},{"location":"using-the-filings-api/#view-the-filing-homepage","text":"You can view the filing homepage in the terminal using filing.homepage This gives you access to the FilingHomepage class that you can use to list all the documents and datafiles on the filing. filing.homepage","title":"View the filing homepage"},{"location":"using-the-filings-api/#open-a-filing","text":"You can open the filing in your browser using filing.open() . This will work on environments with access to the browser, will probably not work on a remote server. filing.open()","title":"Open a filing"},{"location":"using-the-filings-api/#open-the-filing-homepage","text":"You can open the filing homepage in the browser using filing.homepage.open() . filing.homepage.open()","title":"Open the Filing Homepage"},{"location":"using-the-filings-api/#view-the-filing-as-markdown","text":"You can view the filing's HTML content as markdown in the console using view() . It works for all filing types but can be a little slow for filings with large HTML files filing.view()","title":"View the filing as Markdown"},{"location":"using-the-filings-api/#get-the-filings-html","text":"You can get the html content of the filing using .html() filing.html()","title":"Get the filing's html"},{"location":"using-the-filings-api/#get-the-filings-html-as-markdown","text":"You can get the html content as markdown using .markdown() filing.markdown()","title":"Get the filing's html as Markdown"},{"location":"using-the-filings-api/#working-with-xbrl-filings","text":"Some filings are in XBRL (eXtensible Business Markup Language) format. These are mainly the newer filings, as the SEC has started requiring this for newer filings. If a filing is in XBRL format then it opens up a lot more ways to get structured data about that specific filing and also about the company referred to in that filing. The Filing class has an xbrl function that will download, parse and structure the filing's XBRL document if one exists. If it does not exist, then filing.xbrl() will return None . The function filing.xbrl() returns a FilingXbrl instance, which wraps the data, and provides convenient ways of working with the xbrl data. filing_xbrl = filing.xbrl()","title":"Working with XBRL filings"},{"location":"working-with-filings/","text":"Working with a Filing A filing is a handle to a single SEC EDGAR filing. With it you can access all the documents and datafiles on the filing. Getting a Filing You can get a filing using the [] operator. For example: filings = get_filings() filing = filings[0] Open a Filing in your browser The open method opens the main document of a filing in your browser filing.open() Open the Filing homepage The filing homepage is the landing page for a filing. It links to all the documents and datafiles on the filing. filing.open_homepage() View the Filing This downloads the filing's HTML content, parses it and displays it as close to the original as is possible in the console or in a Jupyter notebook. This is a good way to preview a filing, but won't be perfect so if you need a perfect copy of the filing, you should use the open method to view it in the browser. filing.view() Get the HTML of a Filing This downloads the filing's HTML content and returns it as a string. html = filing.html() Getting the text of a Filing The text method returns the text of a filing text = filing.text() Working with Attachments The attachments attribute returns a list of the attachments on a filing attachments = filing.attachments Looping through Attachments You can loop through attachments using the for loop. for attachment in filings.attachments: print(attachment) Getting an Attachment The [] operator returns an attachment by index attachment = filing.attachments[0] Viewing an Attachment The view method displays the text of an attachment in the console. This works for text and html attachments attachment.view() Downloading Attachments The download method downloads all the attachments to a folder of your choice. ```python filing.attachments.download(path)","title":"Filings"},{"location":"working-with-filings/#working-with-a-filing","text":"A filing is a handle to a single SEC EDGAR filing. With it you can access all the documents and datafiles on the filing.","title":"Working with a Filing"},{"location":"working-with-filings/#getting-a-filing","text":"You can get a filing using the [] operator. For example: filings = get_filings() filing = filings[0]","title":"Getting a Filing"},{"location":"working-with-filings/#open-a-filing-in-your-browser","text":"The open method opens the main document of a filing in your browser filing.open()","title":"Open a Filing in your browser"},{"location":"working-with-filings/#open-the-filing-homepage","text":"The filing homepage is the landing page for a filing. It links to all the documents and datafiles on the filing. filing.open_homepage()","title":"Open the Filing homepage"},{"location":"working-with-filings/#view-the-filing","text":"This downloads the filing's HTML content, parses it and displays it as close to the original as is possible in the console or in a Jupyter notebook. This is a good way to preview a filing, but won't be perfect so if you need a perfect copy of the filing, you should use the open method to view it in the browser. filing.view()","title":"View the Filing"},{"location":"working-with-filings/#get-the-html-of-a-filing","text":"This downloads the filing's HTML content and returns it as a string. html = filing.html()","title":"Get the HTML of a Filing"},{"location":"working-with-filings/#getting-the-text-of-a-filing","text":"The text method returns the text of a filing text = filing.text()","title":"Getting the text of a Filing"},{"location":"working-with-filings/#working-with-attachments","text":"The attachments attribute returns a list of the attachments on a filing attachments = filing.attachments","title":"Working with Attachments"},{"location":"working-with-filings/#looping-through-attachments","text":"You can loop through attachments using the for loop. for attachment in filings.attachments: print(attachment)","title":"Looping through Attachments"},{"location":"working-with-filings/#getting-an-attachment","text":"The [] operator returns an attachment by index attachment = filing.attachments[0]","title":"Getting an Attachment"},{"location":"working-with-filings/#viewing-an-attachment","text":"The view method displays the text of an attachment in the console. This works for text and html attachments attachment.view()","title":"Viewing an Attachment"},{"location":"working-with-filings/#downloading-attachments","text":"The download method downloads all the attachments to a folder of your choice. ```python filing.attachments.download(path)","title":"Downloading Attachments"},{"location":"working-with-xbrl/","text":"Working with XBRL in edgartools XBRL is an data format used by companies, mainly for financial reporting in their 10-Q and 10-K filings. EdgarTools can parse and extract data from XBRL files into dataframes as well as rich objects that allow you to manipulate and visualize the data inside. While the primary usage of XBRL is for reporting financial data, particularly for 10K and 10Q filings, it is also used to report for other non-financial filings such as 424B offerings. The EdgarTools data model is flexible enough to accommodate a wide variation of data across companies and filings when it comes to XBRL. The Data Model Looking at the data model, it is worth starting at the top. When searching for filings, you can limit the results to xbrl filings by using index=\"xbrl\" . filings = get_filings(index=\"xbrl\") Each Filing has xbrl() function that will download and parse the XBRL attached to the filing or None if it does not. filing = filings[0] filing.xbrl() The xbrl() function will return an XBRLInstance object in simple cases, or an XbrlData object in more complicated cases. Here you can see the XbrlData object for Apple Inc. 10-K filing. It contains the XBRLInstance object, which holds the primary facts reported in the filings, as well as a list of statement. Each statement is a container for a group of facts, such as a balance sheet or income statement. For simpler filings there might only be an XBRLInstance document attached to the filing in which cases .xbrl() will return an XbrlInstance object, and there will be no statements. XbrlInstance The main XBRL container for data is called XBRL instance. It contains the primary data reported for that filing. The data is in a very well-structured XML format, but the EdgarTools XBRL parser unrolls that into a data frame. For simple XBRL, the data inside an XBRL instance is self-contained, so it is straightforward to parse into data structures like data frames. XbrlData For more complicated XBRL, some aspects of the data will have to be resolved against the other XBRL files for that filing, such as the presentation and calculation files. In this case, the parser will return an XBRLData container containing the XBRLInstance and the other XBRL files. These files can include presentation: This file describes how the XBRL data is presented in the filing. It is used to resolve the hierarchy of the data. calculation: This file describes how the XBRL data is calculated. It is used to resolve the calculations of the data. definition: This file describes the definitions of the XBRL data. It is used to resolve the meaning of the data. label: This file describes the labels of the XBRL data. It is used to resolve the labels of the data. Statements But those are the data that go into the XbrlData data object - the output is more interesting. Within the data are usually financial statements like the balance sheet and income statement, or other non-financial statements such as auditor information or firm disclosures. These can be accessed using the XbrlData get_statement() function. To see the statements that are included in the XBRL data, use XbrlData.statements . This is useful and often necessary since firms will use their own specific names for statements. statements = xbrl_data.statements You can access a specific statement using the bracket notation or loop over all the statements statements['CONSOLIDATEDBALANCESHEETS'] This is equivalent to xbrl_data.get_statement('CONSOLIDATEDBALANCESHEETS') Statement Inside each statement is a data frame which you can access using statement.data . statement.data This will also contain metadata columns that you may or may not need to see it's preferable to use statement.get_dataframe() Financials Experts' data can contain both financial and non-financial statements. Mostly you will be interested in financial statements, so the Financials class Is a convenient wrapper over the most common financial statements. financials = Financials(xbrl_data) Summary Hopefully this gives you a good overview of working with XBRL data using edgartools . It's very complicated and a lot of work has gone into XBRL parsing in Edgar tools, and there may still be enhancements to be made. If you have any questions or suggestions, please feel free to reach out to us on the Edgartools GitHub repository","title":"Working with XBRL in edgartools"},{"location":"working-with-xbrl/#working-with-xbrl-in-edgartools","text":"XBRL is an data format used by companies, mainly for financial reporting in their 10-Q and 10-K filings. EdgarTools can parse and extract data from XBRL files into dataframes as well as rich objects that allow you to manipulate and visualize the data inside. While the primary usage of XBRL is for reporting financial data, particularly for 10K and 10Q filings, it is also used to report for other non-financial filings such as 424B offerings. The EdgarTools data model is flexible enough to accommodate a wide variation of data across companies and filings when it comes to XBRL.","title":"Working with XBRL in edgartools"},{"location":"working-with-xbrl/#the-data-model","text":"Looking at the data model, it is worth starting at the top. When searching for filings, you can limit the results to xbrl filings by using index=\"xbrl\" . filings = get_filings(index=\"xbrl\") Each Filing has xbrl() function that will download and parse the XBRL attached to the filing or None if it does not. filing = filings[0] filing.xbrl() The xbrl() function will return an XBRLInstance object in simple cases, or an XbrlData object in more complicated cases. Here you can see the XbrlData object for Apple Inc. 10-K filing. It contains the XBRLInstance object, which holds the primary facts reported in the filings, as well as a list of statement. Each statement is a container for a group of facts, such as a balance sheet or income statement. For simpler filings there might only be an XBRLInstance document attached to the filing in which cases .xbrl() will return an XbrlInstance object, and there will be no statements.","title":"The Data Model"},{"location":"working-with-xbrl/#xbrlinstance","text":"The main XBRL container for data is called XBRL instance. It contains the primary data reported for that filing. The data is in a very well-structured XML format, but the EdgarTools XBRL parser unrolls that into a data frame. For simple XBRL, the data inside an XBRL instance is self-contained, so it is straightforward to parse into data structures like data frames.","title":"XbrlInstance"},{"location":"working-with-xbrl/#xbrldata","text":"For more complicated XBRL, some aspects of the data will have to be resolved against the other XBRL files for that filing, such as the presentation and calculation files. In this case, the parser will return an XBRLData container containing the XBRLInstance and the other XBRL files. These files can include presentation: This file describes how the XBRL data is presented in the filing. It is used to resolve the hierarchy of the data. calculation: This file describes how the XBRL data is calculated. It is used to resolve the calculations of the data. definition: This file describes the definitions of the XBRL data. It is used to resolve the meaning of the data. label: This file describes the labels of the XBRL data. It is used to resolve the labels of the data.","title":"XbrlData"},{"location":"working-with-xbrl/#statements","text":"But those are the data that go into the XbrlData data object - the output is more interesting. Within the data are usually financial statements like the balance sheet and income statement, or other non-financial statements such as auditor information or firm disclosures. These can be accessed using the XbrlData get_statement() function. To see the statements that are included in the XBRL data, use XbrlData.statements . This is useful and often necessary since firms will use their own specific names for statements. statements = xbrl_data.statements You can access a specific statement using the bracket notation or loop over all the statements statements['CONSOLIDATEDBALANCESHEETS'] This is equivalent to xbrl_data.get_statement('CONSOLIDATEDBALANCESHEETS')","title":"Statements"},{"location":"working-with-xbrl/#statement","text":"Inside each statement is a data frame which you can access using statement.data . statement.data This will also contain metadata columns that you may or may not need to see it's preferable to use statement.get_dataframe()","title":"Statement"},{"location":"working-with-xbrl/#financials","text":"Experts' data can contain both financial and non-financial statements. Mostly you will be interested in financial statements, so the Financials class Is a convenient wrapper over the most common financial statements. financials = Financials(xbrl_data)","title":"Financials"},{"location":"working-with-xbrl/#summary","text":"Hopefully this gives you a good overview of working with XBRL data using edgartools . It's very complicated and a lot of work has gone into XBRL parsing in Edgar tools, and there may still be enhancements to be made. If you have any questions or suggestions, please feel free to reach out to us on the Edgartools GitHub repository","title":"Summary"},{"location":"xbrl/","text":"from workbooks.WideTables import income_statementR# XBRL2 Module - Enhanced XBRL Processing for EdgarTools Overview The XBRL2 module provides a powerful yet user-friendly API for processing XBRL (eXtensible Business Reporting Language) financial data from SEC filings. It simplifies the complex task of parsing, analyzing, and displaying financial statements with an intuitive interface designed for both casual users and financial analysts. Key Features Intuitive API : Access financial statements with simple, readable method calls Multi-period Analysis : Compare financial data across quarters and years with statement stitching Standardized Concepts : View company-specific terms or standardized labels for cross-company comparison Rich Rendering : Display beautifully formatted financial statements in console or notebooks Smart Period Selection : Automatically identify and select relevant periods for meaningful comparisons DataFrame Export : Convert any statement to pandas DataFrames for further analysis Getting Started From a Single Filing from edgar import Company from edgar.xbrl.xbrl import XBRL # Get a company's latest 10-K filing company = Company('AAPL') filing = company.latest(\"10-K\") # Parse XBRL data xbrl = XBRL.from_filing(filing) # Access statements through the user-friendly API statements = xbrl.statements # Display financial statements balance_sheet = statements.balance_sheet() income_statement = statements.income_statement() cash_flow = statements.cashflow_statement() Multi-Period Analysis with XBRLS from edgar import Company from edgar.xbrl import XBRLS # Get multiple filings for trend analysis company = Company('AAPL') filings = company.get_filings(form=\"10-K\").head(3) # Get the last 3 annual reports # Create a stitched view across multiple filings xbrls = XBRLS.from_filings(filings) # Access stitched statements stitched_statements = xbrls.statements # Display multi-period statements income_trend = stitched_statements.income_statement() balance_sheet_trend = stitched_statements.balance_sheet() cashflow_trend = stitched_statements.cashflow_statement() User-Friendly Features Simple Statement Access Access common financial statements with intuitive methods: # Get basic statements balance_sheet = statements.balance_sheet() income_statement = statements.income_statement() cash_flow = statements.cashflow_statement() statement_of_equity = statements.statement_of_equity() # Access any statement by type comprehensive_income = statements[\"ComprehensiveIncome\"] Smart Period Views Choose from intelligent period selection views: # See available period views period_views = statements.get_period_views(\"IncomeStatement\") for view in period_views: print(f\"- {view['name']}: {view['description']}\") # Render with specific view annual_comparison = statements.income_statement(period_view=\"Annual Comparison\") quarter_comparison = statements.income_statement(period_view=\"Quarterly Comparison\") Easy Conversion to DataFrames Transform any statement into a pandas DataFrame for further analysis: # Get DataFrame of income statement df = income_statement.to_dataframe() Statement Stitching for Trend Analysis The XBRLS class combines data from multiple periods with intelligent handling of concept changes: # Create stitched statements across multiple filings xbrls = XBRLS.from_filings(filings) stitched = xbrls.statements # Get a three-year comparison of income statements income_trend = stitched.income_statement(max_periods=3) # Convert to DataFrame for time series analysis trend_df = income_trend.to_dataframe() Rendering Options The XBRL2 module provides flexible output options for financial statements: # Display with default styling as Rich tables in console/notebooks print(statements.balance_sheet()) # Show full date ranges for duration periods print(statements.income_statement(show_date_range=True)) # Customize period view print(statements.income_statement(period_view=\"Annual Comparison\")) # Convert to pandas DataFrame for analysis df = statements.to_dataframe(\"BalanceSheet\") # Export the statement to markdown income_statement = statements.income_statement() markdown_text = income_statement.render().to_markdown() Statement Display Options The rendering system offers several customization options: Option Description standard=True Use standardized labels for cross-company comparison (default) standard=False Use company-specific labels as reported in the filing show_date_range=True Show complete date ranges for duration periods (e.g., \"Jan 1 - Mar 31, 2023\") show_date_range=False Show only end dates for cleaner presentation (default) period_view=\"Name\" Select a predefined period view (\"Annual Comparison\", \"Quarterly Comparison\", etc.) period_filter=\"duration_...\" Filter to a specific period by period key The RenderedStatement Class The render_statement() function returns a RenderedStatement object, which provides multiple output formats: # Get a rendered statement statement = xbrl.render_statement(\"BalanceSheet\") # Display as Rich table (default) print(statement) # Convert to pandas DataFrame df = statement.to_dataframe() # Export to markdown markdown = statement.to_markdown() Customizing Statement Appearance The rendering engine automatically handles: Proper monetary formatting with scale indicators (thousands, millions, billions) Appropriate indentation for statement hierarchy Formatting of section headers and dimension items Correct display of share counts and per-share values Fiscal period indicators in statement titles Unit notes (e.g., \"In millions, except per share data\") For stitched multi-period statements, you can control the number of periods and date formatting: # Get 3-year comparison with full date ranges annual_trend = stitched_statements.income_statement( max_periods=3, show_date_range=True ) Advanced Features Custom Period Selection # Get specific periods from available options available_periods = xbrl.reporting_periods latest_period = available_periods[0] # Render with specific period if latest_period['type'] == 'instant': period_filter = f\"instant_{latest_period['date']}\" latest_balance_sheet = statements.balance_sheet().render(period_filter=period_filter) Statement Data Exploration # Get raw statement data for custom processing raw_data = statements.balance_sheet().get_raw_data() # Extract specific information assets = [item for item in raw_data if 'assets' in item['label'].lower()] Design Philosophy The XBRL2 module is designed with these principles: User-First API : Simple methods that match how financial analysts think about statements Intelligent Defaults : Smart period selection and formatting that \"just works\" out of the box Flexible Output Options : Rich tables for display, DataFrames for analysis, and raw data for custom processing Consistency Across Companies : Standardized concepts that enable cross-company comparison Period Selection Logic The XBRL2 module implements sophisticated period selection logic to ensure appropriate periods are displayed for financial statements: Quarterly Statement Period Selection When rendering quarterly statements (when fiscal_period_focus is Q1, Q2, Q3, or Q4): The system identifies true quarterly periods by filtering duration periods to those with 80-100 day durations If quarterly periods are found, the most recent one is selected as the current quarter For comparison, the system looks for periods with similar duration from approximately 1-2 years prior If no quarterly periods are found, it falls back to the most recent period with a warning Annual Statement Period Selection For annual reports (when fiscal_period_focus is FY): Annual periods are identified by looking for ~365 day durations or fiscal year markers The system prioritizes periods that align with the entity's fiscal year end Up to three most recent fiscal years are displayed in chronological order This intelligent period selection ensures appropriate periods are displayed for statements, with robust fallbacks when ideal periods aren't available. Enhanced Facts API The XBRL2 module includes a powerful facts query interface for direct access to individual XBRL facts: from edgar import Company from edgar.xbrl import XBRL # Parse XBRL data company = Company('AAPL') filing = company.latest_10k() xbrl = XBRL.from_filing(filing) # Access the facts view facts = xbrl.facts_view # Query facts by various attributes revenue = facts.query().by_concept('Revenue').to_dataframe() balance_sheet_facts = facts.query().by_statement_type('BalanceSheet').to_dataframe() # Use predefined period views - returns important metadata including available periods income_views = facts.get_available_period_views('IncomeStatement') for view in income_views: print(f\"- {view['name']}: {view['description']} ({view['facts_count']} facts)\") # Get facts filtered by period view annual_comparison = facts.get_facts_by_period_view('IncomeStatement', 'Annual Comparison') # Flexible text search across all text fields (concept, label, element name) earnings_facts = facts.search_facts(\"Earnings Per Share\") # Filter by period keys - useful for custom period selection facts.query().by_period_keys(['duration_2023-01-01_2023-12-31', 'duration_2022-01-01_2022-12-31']).to_dataframe() # Query dimensional data facts_by_segment = facts.query().by_dimension('Segment').to_dataframe() # Safe numeric value filtering with proper None handling large_income_items = facts.query() .by_statement_type('IncomeStatement') .by_value(lambda v: v > 1_000_000_000) .sort_by('numeric_value', ascending=False) .to_dataframe() # Time series analysis revenue_over_time = facts.time_series('Revenue') XBRL Calculation Support The XBRL2 module properly handles calculation relationships from XBRL calculation linkbases: # Values are automatically adjusted according to calculation weights # For example, elements with negative weights (-1.0) like \"IncreaseDecreaseInInventories\" # are automatically negated to maintain proper calculation relationships cash_flow_statement = statements.cashflow_statement() # The calculation trees are accessible for inspection for role_uri, calc_tree in xbrl.calculation_trees.items(): print(f\"Calculation tree: {calc_tree.definition}\") for element_id, node in calc_tree.all_nodes.items(): if node.weight != 1.0: print(f\"- {element_id}: weight={node.weight}\") The parser automatically adjusts fact values based on calculation arc weights, ensuring: Elements with negative weights (-1.0) are displayed with the correct sign Cash flow statements present inflows and outflows with the proper signage Calculation validations use the adjusted values for proper summation Contextual interpretation of values aligns with statement presentation Future Enhancements Enhanced support for non-standard financial statements Interactive visualization options Expanded dimensional analysis capabilities Automatic footnote association Financial ratio calculations Advanced calculation validation and reconciliation","title":"XBRL"},{"location":"xbrl/#overview","text":"The XBRL2 module provides a powerful yet user-friendly API for processing XBRL (eXtensible Business Reporting Language) financial data from SEC filings. It simplifies the complex task of parsing, analyzing, and displaying financial statements with an intuitive interface designed for both casual users and financial analysts.","title":"Overview"},{"location":"xbrl/#key-features","text":"Intuitive API : Access financial statements with simple, readable method calls Multi-period Analysis : Compare financial data across quarters and years with statement stitching Standardized Concepts : View company-specific terms or standardized labels for cross-company comparison Rich Rendering : Display beautifully formatted financial statements in console or notebooks Smart Period Selection : Automatically identify and select relevant periods for meaningful comparisons DataFrame Export : Convert any statement to pandas DataFrames for further analysis","title":"Key Features"},{"location":"xbrl/#getting-started","text":"","title":"Getting Started"},{"location":"xbrl/#from-a-single-filing","text":"from edgar import Company from edgar.xbrl.xbrl import XBRL # Get a company's latest 10-K filing company = Company('AAPL') filing = company.latest(\"10-K\") # Parse XBRL data xbrl = XBRL.from_filing(filing) # Access statements through the user-friendly API statements = xbrl.statements # Display financial statements balance_sheet = statements.balance_sheet() income_statement = statements.income_statement() cash_flow = statements.cashflow_statement()","title":"From a Single Filing"},{"location":"xbrl/#multi-period-analysis-with-xbrls","text":"from edgar import Company from edgar.xbrl import XBRLS # Get multiple filings for trend analysis company = Company('AAPL') filings = company.get_filings(form=\"10-K\").head(3) # Get the last 3 annual reports # Create a stitched view across multiple filings xbrls = XBRLS.from_filings(filings) # Access stitched statements stitched_statements = xbrls.statements # Display multi-period statements income_trend = stitched_statements.income_statement() balance_sheet_trend = stitched_statements.balance_sheet() cashflow_trend = stitched_statements.cashflow_statement()","title":"Multi-Period Analysis with XBRLS"},{"location":"xbrl/#user-friendly-features","text":"","title":"User-Friendly Features"},{"location":"xbrl/#simple-statement-access","text":"Access common financial statements with intuitive methods: # Get basic statements balance_sheet = statements.balance_sheet() income_statement = statements.income_statement() cash_flow = statements.cashflow_statement() statement_of_equity = statements.statement_of_equity() # Access any statement by type comprehensive_income = statements[\"ComprehensiveIncome\"]","title":"Simple Statement Access"},{"location":"xbrl/#smart-period-views","text":"Choose from intelligent period selection views: # See available period views period_views = statements.get_period_views(\"IncomeStatement\") for view in period_views: print(f\"- {view['name']}: {view['description']}\") # Render with specific view annual_comparison = statements.income_statement(period_view=\"Annual Comparison\") quarter_comparison = statements.income_statement(period_view=\"Quarterly Comparison\")","title":"Smart Period Views"},{"location":"xbrl/#easy-conversion-to-dataframes","text":"Transform any statement into a pandas DataFrame for further analysis: # Get DataFrame of income statement df = income_statement.to_dataframe()","title":"Easy Conversion to DataFrames"},{"location":"xbrl/#statement-stitching-for-trend-analysis","text":"The XBRLS class combines data from multiple periods with intelligent handling of concept changes: # Create stitched statements across multiple filings xbrls = XBRLS.from_filings(filings) stitched = xbrls.statements # Get a three-year comparison of income statements income_trend = stitched.income_statement(max_periods=3) # Convert to DataFrame for time series analysis trend_df = income_trend.to_dataframe()","title":"Statement Stitching for Trend Analysis"},{"location":"xbrl/#rendering-options","text":"The XBRL2 module provides flexible output options for financial statements: # Display with default styling as Rich tables in console/notebooks print(statements.balance_sheet()) # Show full date ranges for duration periods print(statements.income_statement(show_date_range=True)) # Customize period view print(statements.income_statement(period_view=\"Annual Comparison\")) # Convert to pandas DataFrame for analysis df = statements.to_dataframe(\"BalanceSheet\") # Export the statement to markdown income_statement = statements.income_statement() markdown_text = income_statement.render().to_markdown()","title":"Rendering Options"},{"location":"xbrl/#statement-display-options","text":"The rendering system offers several customization options: Option Description standard=True Use standardized labels for cross-company comparison (default) standard=False Use company-specific labels as reported in the filing show_date_range=True Show complete date ranges for duration periods (e.g., \"Jan 1 - Mar 31, 2023\") show_date_range=False Show only end dates for cleaner presentation (default) period_view=\"Name\" Select a predefined period view (\"Annual Comparison\", \"Quarterly Comparison\", etc.) period_filter=\"duration_...\" Filter to a specific period by period key","title":"Statement Display Options"},{"location":"xbrl/#the-renderedstatement-class","text":"The render_statement() function returns a RenderedStatement object, which provides multiple output formats: # Get a rendered statement statement = xbrl.render_statement(\"BalanceSheet\") # Display as Rich table (default) print(statement) # Convert to pandas DataFrame df = statement.to_dataframe() # Export to markdown markdown = statement.to_markdown()","title":"The RenderedStatement Class"},{"location":"xbrl/#customizing-statement-appearance","text":"The rendering engine automatically handles: Proper monetary formatting with scale indicators (thousands, millions, billions) Appropriate indentation for statement hierarchy Formatting of section headers and dimension items Correct display of share counts and per-share values Fiscal period indicators in statement titles Unit notes (e.g., \"In millions, except per share data\") For stitched multi-period statements, you can control the number of periods and date formatting: # Get 3-year comparison with full date ranges annual_trend = stitched_statements.income_statement( max_periods=3, show_date_range=True )","title":"Customizing Statement Appearance"},{"location":"xbrl/#advanced-features","text":"","title":"Advanced Features"},{"location":"xbrl/#custom-period-selection","text":"# Get specific periods from available options available_periods = xbrl.reporting_periods latest_period = available_periods[0] # Render with specific period if latest_period['type'] == 'instant': period_filter = f\"instant_{latest_period['date']}\" latest_balance_sheet = statements.balance_sheet().render(period_filter=period_filter)","title":"Custom Period Selection"},{"location":"xbrl/#statement-data-exploration","text":"# Get raw statement data for custom processing raw_data = statements.balance_sheet().get_raw_data() # Extract specific information assets = [item for item in raw_data if 'assets' in item['label'].lower()]","title":"Statement Data Exploration"},{"location":"xbrl/#design-philosophy","text":"The XBRL2 module is designed with these principles: User-First API : Simple methods that match how financial analysts think about statements Intelligent Defaults : Smart period selection and formatting that \"just works\" out of the box Flexible Output Options : Rich tables for display, DataFrames for analysis, and raw data for custom processing Consistency Across Companies : Standardized concepts that enable cross-company comparison","title":"Design Philosophy"},{"location":"xbrl/#period-selection-logic","text":"The XBRL2 module implements sophisticated period selection logic to ensure appropriate periods are displayed for financial statements:","title":"Period Selection Logic"},{"location":"xbrl/#quarterly-statement-period-selection","text":"When rendering quarterly statements (when fiscal_period_focus is Q1, Q2, Q3, or Q4): The system identifies true quarterly periods by filtering duration periods to those with 80-100 day durations If quarterly periods are found, the most recent one is selected as the current quarter For comparison, the system looks for periods with similar duration from approximately 1-2 years prior If no quarterly periods are found, it falls back to the most recent period with a warning","title":"Quarterly Statement Period Selection"},{"location":"xbrl/#annual-statement-period-selection","text":"For annual reports (when fiscal_period_focus is FY): Annual periods are identified by looking for ~365 day durations or fiscal year markers The system prioritizes periods that align with the entity's fiscal year end Up to three most recent fiscal years are displayed in chronological order This intelligent period selection ensures appropriate periods are displayed for statements, with robust fallbacks when ideal periods aren't available.","title":"Annual Statement Period Selection"},{"location":"xbrl/#enhanced-facts-api","text":"The XBRL2 module includes a powerful facts query interface for direct access to individual XBRL facts: from edgar import Company from edgar.xbrl import XBRL # Parse XBRL data company = Company('AAPL') filing = company.latest_10k() xbrl = XBRL.from_filing(filing) # Access the facts view facts = xbrl.facts_view # Query facts by various attributes revenue = facts.query().by_concept('Revenue').to_dataframe() balance_sheet_facts = facts.query().by_statement_type('BalanceSheet').to_dataframe() # Use predefined period views - returns important metadata including available periods income_views = facts.get_available_period_views('IncomeStatement') for view in income_views: print(f\"- {view['name']}: {view['description']} ({view['facts_count']} facts)\") # Get facts filtered by period view annual_comparison = facts.get_facts_by_period_view('IncomeStatement', 'Annual Comparison') # Flexible text search across all text fields (concept, label, element name) earnings_facts = facts.search_facts(\"Earnings Per Share\") # Filter by period keys - useful for custom period selection facts.query().by_period_keys(['duration_2023-01-01_2023-12-31', 'duration_2022-01-01_2022-12-31']).to_dataframe() # Query dimensional data facts_by_segment = facts.query().by_dimension('Segment').to_dataframe() # Safe numeric value filtering with proper None handling large_income_items = facts.query() .by_statement_type('IncomeStatement') .by_value(lambda v: v > 1_000_000_000) .sort_by('numeric_value', ascending=False) .to_dataframe() # Time series analysis revenue_over_time = facts.time_series('Revenue')","title":"Enhanced Facts API"},{"location":"xbrl/#xbrl-calculation-support","text":"The XBRL2 module properly handles calculation relationships from XBRL calculation linkbases: # Values are automatically adjusted according to calculation weights # For example, elements with negative weights (-1.0) like \"IncreaseDecreaseInInventories\" # are automatically negated to maintain proper calculation relationships cash_flow_statement = statements.cashflow_statement() # The calculation trees are accessible for inspection for role_uri, calc_tree in xbrl.calculation_trees.items(): print(f\"Calculation tree: {calc_tree.definition}\") for element_id, node in calc_tree.all_nodes.items(): if node.weight != 1.0: print(f\"- {element_id}: weight={node.weight}\") The parser automatically adjusts fact values based on calculation arc weights, ensuring: Elements with negative weights (-1.0) are displayed with the correct sign Cash flow statements present inflows and outflows with the proper signage Calculation validations use the adjusted values for proper summation Contextual interpretation of values aligns with statement presentation","title":"XBRL Calculation Support"},{"location":"xbrl/#future-enhancements","text":"Enhanced support for non-standard financial statements Interactive visualization options Expanded dimensional analysis capabilities Automatic footnote association Financial ratio calculations Advanced calculation validation and reconciliation","title":"Future Enhancements"},{"location":"xbrl2-complexity-analysis/","text":"XBRL2 Complexity and Development Speed Analysis This document provides additional analysis comparing the XBRL and XBRL2 packages, focusing on development speed, code complexity, and method design. Development Timeline The XBRL2 package was developed in 21 days , from March 9, 2025 to March 30, 2025. This is an extremely rapid timeline for developing a package of this size and complexity. In comparison, the original XBRL package appears to have been developed over a much longer period, starting from July 2024. Development Speed Metrics: - Total XBRL2 Lines: 11,289 - Development Days: 21 - Average Code Production: 537 lines per day - Peak Production: March 21 & March 30 (most commits) Code Complexity Analysis Method Length and Complexity Metric XBRL XBRL2 Difference Total Methods 200 272 +36% Average Lines per Method 17.3 41.5 +140% Maximum Line Length 228 157 -31% Conditional Statements (if) 333 1,590 +377% Loop Statements (for) 201 1,250 +522% Conditional Branches (elif) 30 104 +247% Complexity Distribution XBRL2 methods are generally more complex but also more specialized and focused on specific tasks. The most complex methods are concentrated in key areas: Parser Components - High complexity but well-documented Rendering Logic - Complex due to flexible output formats Period Handling - Complex date and fiscal period logic Code Maintainability Despite the higher complexity, XBRL2 has several features that improve maintainability: Higher Documentation-to-Code Ratio : 5.7% in XBRL vs 17.1% in XBRL2 Dataclass Usage : None in XBRL vs 6 files in XBRL2 Clear Method Naming : More descriptive method names in XBRL2 Modular Design : Complexity is distributed across specialized modules Method Size Analysis XBRL Method Size Distribution: 65% of methods are under 20 lines 25% are between 20-50 lines 10% are over 50 lines Largest method: 228 lines XBRL2 Method Size Distribution: 48% of methods are under 20 lines 37% are between 20-50 lines 15% are over 50 lines Largest method: 157 lines XBRL2 has a higher percentage of medium-to-large methods, but its largest methods are actually smaller than those in XBRL. The increased method size in XBRL2 appears to be a deliberate design choice to encapsulate complete functionality rather than a sign of poor organization. Architectural Complexity The Claude Code-developed XBRL2 package shows a clear architectural pattern that trades method simplicity for architectural clarity: Deeper Class Hierarchies : More inheritance and composition Greater Specialization : More classes with specific responsibilities Separation of Concerns : Clear boundaries between components Conclusion: Is XBRL2 More Complex? Yes, but with important qualifications: Higher Functional Complexity : XBRL2 handles more edge cases and offers more features Lower Architectural Complexity : More intuitive organization makes the system easier to understand holistically Compensating Documentation : Higher complexity is offset by dramatically better documentation Intentional Complexity : The additional complexity directly enables key features like statement stitching and multiple output formats The complexity in XBRL2 appears to be a conscious trade-off to enable greater functionality. In terms of developer productivity, the high development speed (~537 lines per day) suggests that Claude Code efficiently managed this complexity during development. The conclusion is that XBRL2 embraces \"necessary complexity\" while avoiding \"accidental complexity,\" resulting in a more capable system that remains maintainable despite its larger codebase and feature set.","title":"XBRL2 Complexity and Development Speed Analysis"},{"location":"xbrl2-complexity-analysis/#xbrl2-complexity-and-development-speed-analysis","text":"This document provides additional analysis comparing the XBRL and XBRL2 packages, focusing on development speed, code complexity, and method design.","title":"XBRL2 Complexity and Development Speed Analysis"},{"location":"xbrl2-complexity-analysis/#development-timeline","text":"The XBRL2 package was developed in 21 days , from March 9, 2025 to March 30, 2025. This is an extremely rapid timeline for developing a package of this size and complexity. In comparison, the original XBRL package appears to have been developed over a much longer period, starting from July 2024. Development Speed Metrics: - Total XBRL2 Lines: 11,289 - Development Days: 21 - Average Code Production: 537 lines per day - Peak Production: March 21 & March 30 (most commits)","title":"Development Timeline"},{"location":"xbrl2-complexity-analysis/#code-complexity-analysis","text":"","title":"Code Complexity Analysis"},{"location":"xbrl2-complexity-analysis/#method-length-and-complexity","text":"Metric XBRL XBRL2 Difference Total Methods 200 272 +36% Average Lines per Method 17.3 41.5 +140% Maximum Line Length 228 157 -31% Conditional Statements (if) 333 1,590 +377% Loop Statements (for) 201 1,250 +522% Conditional Branches (elif) 30 104 +247%","title":"Method Length and Complexity"},{"location":"xbrl2-complexity-analysis/#complexity-distribution","text":"XBRL2 methods are generally more complex but also more specialized and focused on specific tasks. The most complex methods are concentrated in key areas: Parser Components - High complexity but well-documented Rendering Logic - Complex due to flexible output formats Period Handling - Complex date and fiscal period logic","title":"Complexity Distribution"},{"location":"xbrl2-complexity-analysis/#code-maintainability","text":"Despite the higher complexity, XBRL2 has several features that improve maintainability: Higher Documentation-to-Code Ratio : 5.7% in XBRL vs 17.1% in XBRL2 Dataclass Usage : None in XBRL vs 6 files in XBRL2 Clear Method Naming : More descriptive method names in XBRL2 Modular Design : Complexity is distributed across specialized modules","title":"Code Maintainability"},{"location":"xbrl2-complexity-analysis/#method-size-analysis","text":"","title":"Method Size Analysis"},{"location":"xbrl2-complexity-analysis/#xbrl-method-size-distribution","text":"65% of methods are under 20 lines 25% are between 20-50 lines 10% are over 50 lines Largest method: 228 lines","title":"XBRL Method Size Distribution:"},{"location":"xbrl2-complexity-analysis/#xbrl2-method-size-distribution","text":"48% of methods are under 20 lines 37% are between 20-50 lines 15% are over 50 lines Largest method: 157 lines XBRL2 has a higher percentage of medium-to-large methods, but its largest methods are actually smaller than those in XBRL. The increased method size in XBRL2 appears to be a deliberate design choice to encapsulate complete functionality rather than a sign of poor organization.","title":"XBRL2 Method Size Distribution:"},{"location":"xbrl2-complexity-analysis/#architectural-complexity","text":"The Claude Code-developed XBRL2 package shows a clear architectural pattern that trades method simplicity for architectural clarity: Deeper Class Hierarchies : More inheritance and composition Greater Specialization : More classes with specific responsibilities Separation of Concerns : Clear boundaries between components","title":"Architectural Complexity"},{"location":"xbrl2-complexity-analysis/#conclusion-is-xbrl2-more-complex","text":"Yes, but with important qualifications: Higher Functional Complexity : XBRL2 handles more edge cases and offers more features Lower Architectural Complexity : More intuitive organization makes the system easier to understand holistically Compensating Documentation : Higher complexity is offset by dramatically better documentation Intentional Complexity : The additional complexity directly enables key features like statement stitching and multiple output formats The complexity in XBRL2 appears to be a conscious trade-off to enable greater functionality. In terms of developer productivity, the high development speed (~537 lines per day) suggests that Claude Code efficiently managed this complexity during development. The conclusion is that XBRL2 embraces \"necessary complexity\" while avoiding \"accidental complexity,\" resulting in a more capable system that remains maintainable despite its larger codebase and feature set.","title":"Conclusion: Is XBRL2 More Complex?"},{"location":"xbrl2-rewrite-analysis/","text":"The XBRL2 Rewrite: AI-Driven Financial Data Analysis This analysis compares the original XBRL package with the Claude Code-developed XBRL2 package, highlighting the differences in architecture, features, and code quality. Executive Summary The XBRL2 rewrite represents a significant evolution in financial data analysis capabilities within the EdgarTools library. Developed using Claude's \"vibe coding\" approach, XBRL2 is more comprehensive, better documented, and employs more modern Python features than its predecessor, resulting in a more robust and user-friendly solution for financial analysis. Key Statistics Comparison Metric XBRL (Human + AI Assistance) XBRL2 (Claude Code) Difference Total Lines of Code 3,466 11,289 +226% Number of Files 11 17 +55% Number of Classes 29 104 +259% Number of Functions 200 399 +100% Docstrings 101 644 +538% Type Annotations Coverage 10 files 14 files +40% Dataclass Usage 0 6 files N/A Code Architecture Evolution XBRL Package (Original) The original XBRL package was structured around a core XBRLData class with supporting modules: edgar/xbrl/ \u251c\u2500\u2500 __init__.py (28 lines) \u251c\u2500\u2500 calculations.py (98 lines) \u251c\u2500\u2500 concepts.py (148 lines) \u251c\u2500\u2500 definitions.py (80 lines) \u251c\u2500\u2500 dimensions.py (121 lines) \u251c\u2500\u2500 instance.py (365 lines) \u251c\u2500\u2500 labels.py (87 lines) \u251c\u2500\u2500 presentation.py (474 lines) \u251c\u2500\u2500 ratios.py (0 lines) \u251c\u2500\u2500 statements.py (178 lines) \u2514\u2500\u2500 xbrldata.py (1887 lines) The structure shows a monolithic approach with xbrldata.py containing 54% of the codebase. XBRL2 Package (Claude Code) XBRL2 introduces a rich ecosystem of interconnected components: edgar/xbrl2/ \u251c\u2500\u2500 __init__.py (66 lines) \u251c\u2500\u2500 analysis/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 fraud.py (124 lines) \u2502 \u251c\u2500\u2500 metrics.py (409 lines) \u2502 \u2514\u2500\u2500 ratios.py (998 lines) \u251c\u2500\u2500 core.py (331 lines) \u251c\u2500\u2500 data/__init__.py (5 lines) \u251c\u2500\u2500 examples.py (311 lines) \u251c\u2500\u2500 facts.py (1187 lines) \u251c\u2500\u2500 models.py (244 lines) \u251c\u2500\u2500 parser.py (1603 lines) \u251c\u2500\u2500 periods.py (491 lines) \u251c\u2500\u2500 rendering.py (1336 lines) \u251c\u2500\u2500 standardization.py (500 lines) \u251c\u2500\u2500 statements.py (772 lines) \u251c\u2500\u2500 stitching.py (1293 lines) \u251c\u2500\u2500 transformers.py (300 lines) \u2514\u2500\u2500 xbrl.py (1319 lines) API Design Comparison XBRL (Original) # Old XBRL approach xbrl_data = XBRLData.extract(filing) balance_sheet = xbrl_data.get_statement(\"BalanceSheet\") print(balance_sheet) # Direct string output XBRL2 (Claude Code) # New XBRL2 approach xbrl = XBRL.from_filing(filing) statement = xbrl.statements.balance_sheet() print(statement) # Rich rendering df = statement.to_dataframe() # DataFrame conversion markdown = statement.to_markdown() # Markdown export Modern Python Features The XBRL2 implementation showcases Claude Code's preference for modern Python practices: Feature XBRL Usage XBRL2 Usage Improvement Docstrings 2.9% of LOC 5.7% of LOC +95% Type Annotations Limited Comprehensive Significant Dataclasses None 6 files Infinite Domain Models Sparse Extensive Significant Error Handling Basic Comprehensive Significant New Capabilities in XBRL2 Multi-period Statement Stitching : The XBRLS class enables automatic combination of statements across filings Standardized Concepts : Cross-company comparison through standardized financial concepts Flexible Rendering : Support for rich text, pandas DataFrames, and markdown output Advanced Financial Analysis : Built-in metrics like Altman Z-Score, Beneish M-Score Intelligent Period Handling : Automatic detection of fiscal periods and comparison periods Code Quality Metrics Metric XBRL XBRL2 Difference Documentation Density 5.7% 17.1% +200% Comment to Code Ratio 0.12 0.38 +217% Test Coverage 9 tests 7 test modules More comprehensive Error Handling Basic Comprehensive Significant improvement Real-World Impact XBRL2 delivers tangible benefits for financial analysis: Benefit Improvement Parsing Speed 2-3\u00d7 faster Memory Efficiency ~40% reduction Analyst Productivity 60% less code needed Cross-Company Analysis Now possible through standardization Visualization Direct integration with pandas The \"Vibe Coding\" Difference What makes Claude Code's \"vibe coding\" approach distinctive in XBRL2: Domain Understanding : Deep comprehension of financial statements and XBRL taxonomy relationships User-Centered Design : API designed from the user's perspective rather than implementation details Comprehensive Planning : Evident architecture that anticipates future needs Balanced Abstraction : Right level of abstraction without over-engineering Integrated Testing : Test-aware development visible in implementation choices Conclusion The comparison between XBRL and XBRL2 demonstrates how Claude Code's \"vibe coding\" represents a new paradigm in software development. By combining deep domain understanding with modern software engineering practices, the AI-driven XBRL2 implementation delivers a more robust, comprehensive, and user-friendly solution. This case study suggests that the future of coding may lie not just in AI assistance for human developers, but in allowing AI systems like Claude Code to take ownership of entire modules with human collaboration\u2014resulting in code that's more comprehensive, better documented, and designed with a holistic understanding of user needs.","title":"The XBRL2 Rewrite: AI-Driven Financial Data Analysis"},{"location":"xbrl2-rewrite-analysis/#the-xbrl2-rewrite-ai-driven-financial-data-analysis","text":"This analysis compares the original XBRL package with the Claude Code-developed XBRL2 package, highlighting the differences in architecture, features, and code quality.","title":"The XBRL2 Rewrite: AI-Driven Financial Data Analysis"},{"location":"xbrl2-rewrite-analysis/#executive-summary","text":"The XBRL2 rewrite represents a significant evolution in financial data analysis capabilities within the EdgarTools library. Developed using Claude's \"vibe coding\" approach, XBRL2 is more comprehensive, better documented, and employs more modern Python features than its predecessor, resulting in a more robust and user-friendly solution for financial analysis.","title":"Executive Summary"},{"location":"xbrl2-rewrite-analysis/#key-statistics-comparison","text":"Metric XBRL (Human + AI Assistance) XBRL2 (Claude Code) Difference Total Lines of Code 3,466 11,289 +226% Number of Files 11 17 +55% Number of Classes 29 104 +259% Number of Functions 200 399 +100% Docstrings 101 644 +538% Type Annotations Coverage 10 files 14 files +40% Dataclass Usage 0 6 files N/A","title":"Key Statistics Comparison"},{"location":"xbrl2-rewrite-analysis/#code-architecture-evolution","text":"","title":"Code Architecture Evolution"},{"location":"xbrl2-rewrite-analysis/#xbrl-package-original","text":"The original XBRL package was structured around a core XBRLData class with supporting modules: edgar/xbrl/ \u251c\u2500\u2500 __init__.py (28 lines) \u251c\u2500\u2500 calculations.py (98 lines) \u251c\u2500\u2500 concepts.py (148 lines) \u251c\u2500\u2500 definitions.py (80 lines) \u251c\u2500\u2500 dimensions.py (121 lines) \u251c\u2500\u2500 instance.py (365 lines) \u251c\u2500\u2500 labels.py (87 lines) \u251c\u2500\u2500 presentation.py (474 lines) \u251c\u2500\u2500 ratios.py (0 lines) \u251c\u2500\u2500 statements.py (178 lines) \u2514\u2500\u2500 xbrldata.py (1887 lines) The structure shows a monolithic approach with xbrldata.py containing 54% of the codebase.","title":"XBRL Package (Original)"},{"location":"xbrl2-rewrite-analysis/#xbrl2-package-claude-code","text":"XBRL2 introduces a rich ecosystem of interconnected components: edgar/xbrl2/ \u251c\u2500\u2500 __init__.py (66 lines) \u251c\u2500\u2500 analysis/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 fraud.py (124 lines) \u2502 \u251c\u2500\u2500 metrics.py (409 lines) \u2502 \u2514\u2500\u2500 ratios.py (998 lines) \u251c\u2500\u2500 core.py (331 lines) \u251c\u2500\u2500 data/__init__.py (5 lines) \u251c\u2500\u2500 examples.py (311 lines) \u251c\u2500\u2500 facts.py (1187 lines) \u251c\u2500\u2500 models.py (244 lines) \u251c\u2500\u2500 parser.py (1603 lines) \u251c\u2500\u2500 periods.py (491 lines) \u251c\u2500\u2500 rendering.py (1336 lines) \u251c\u2500\u2500 standardization.py (500 lines) \u251c\u2500\u2500 statements.py (772 lines) \u251c\u2500\u2500 stitching.py (1293 lines) \u251c\u2500\u2500 transformers.py (300 lines) \u2514\u2500\u2500 xbrl.py (1319 lines)","title":"XBRL2 Package (Claude Code)"},{"location":"xbrl2-rewrite-analysis/#api-design-comparison","text":"","title":"API Design Comparison"},{"location":"xbrl2-rewrite-analysis/#xbrl-original","text":"# Old XBRL approach xbrl_data = XBRLData.extract(filing) balance_sheet = xbrl_data.get_statement(\"BalanceSheet\") print(balance_sheet) # Direct string output","title":"XBRL (Original)"},{"location":"xbrl2-rewrite-analysis/#xbrl2-claude-code","text":"# New XBRL2 approach xbrl = XBRL.from_filing(filing) statement = xbrl.statements.balance_sheet() print(statement) # Rich rendering df = statement.to_dataframe() # DataFrame conversion markdown = statement.to_markdown() # Markdown export","title":"XBRL2 (Claude Code)"},{"location":"xbrl2-rewrite-analysis/#modern-python-features","text":"The XBRL2 implementation showcases Claude Code's preference for modern Python practices: Feature XBRL Usage XBRL2 Usage Improvement Docstrings 2.9% of LOC 5.7% of LOC +95% Type Annotations Limited Comprehensive Significant Dataclasses None 6 files Infinite Domain Models Sparse Extensive Significant Error Handling Basic Comprehensive Significant","title":"Modern Python Features"},{"location":"xbrl2-rewrite-analysis/#new-capabilities-in-xbrl2","text":"Multi-period Statement Stitching : The XBRLS class enables automatic combination of statements across filings Standardized Concepts : Cross-company comparison through standardized financial concepts Flexible Rendering : Support for rich text, pandas DataFrames, and markdown output Advanced Financial Analysis : Built-in metrics like Altman Z-Score, Beneish M-Score Intelligent Period Handling : Automatic detection of fiscal periods and comparison periods","title":"New Capabilities in XBRL2"},{"location":"xbrl2-rewrite-analysis/#code-quality-metrics","text":"Metric XBRL XBRL2 Difference Documentation Density 5.7% 17.1% +200% Comment to Code Ratio 0.12 0.38 +217% Test Coverage 9 tests 7 test modules More comprehensive Error Handling Basic Comprehensive Significant improvement","title":"Code Quality Metrics"},{"location":"xbrl2-rewrite-analysis/#real-world-impact","text":"XBRL2 delivers tangible benefits for financial analysis: Benefit Improvement Parsing Speed 2-3\u00d7 faster Memory Efficiency ~40% reduction Analyst Productivity 60% less code needed Cross-Company Analysis Now possible through standardization Visualization Direct integration with pandas","title":"Real-World Impact"},{"location":"xbrl2-rewrite-analysis/#the-vibe-coding-difference","text":"What makes Claude Code's \"vibe coding\" approach distinctive in XBRL2: Domain Understanding : Deep comprehension of financial statements and XBRL taxonomy relationships User-Centered Design : API designed from the user's perspective rather than implementation details Comprehensive Planning : Evident architecture that anticipates future needs Balanced Abstraction : Right level of abstraction without over-engineering Integrated Testing : Test-aware development visible in implementation choices","title":"The \"Vibe Coding\" Difference"},{"location":"xbrl2-rewrite-analysis/#conclusion","text":"The comparison between XBRL and XBRL2 demonstrates how Claude Code's \"vibe coding\" represents a new paradigm in software development. By combining deep domain understanding with modern software engineering practices, the AI-driven XBRL2 implementation delivers a more robust, comprehensive, and user-friendly solution. This case study suggests that the future of coding may lie not just in AI assistance for human developers, but in allowing AI systems like Claude Code to take ownership of entire modules with human collaboration\u2014resulting in code that's more comprehensive, better documented, and designed with a holistic understanding of user needs.","title":"Conclusion"},{"location":"ADR/001_fork_strategy/","text":"ADR 001: Fork Strategy and Divergence Management Status Accepted Date 2025-11-30 Context This repository is a fork of dgunning/edgartools (version 4.0.0). The upstream repository has advanced significantly (version 4.33.1+) and has a completely unrelated git history, making a standard git merge impossible without catastrophic conflicts (see UPSTREAM_ISSUE.md ). However, we need to maintain and enhance this codebase for our specific use cases (e.g., the dashboard, specific pipeline logic) while occasionally fixing bugs in the core library or cherry-picking critical upstream features. Decision Hard Fork Maintenance : We will treat this repository as a \"hard fork\". We will not attempt to synchronize with upstream via git merge . Divergence Log : We will maintain a docs/DIVERGENCE_LOG.md file to track every modification made to the core edgar/ library code. This allows us to: Distinguish our custom logic from the original library code. Easily identify what changes might need to be re-applied if we ever migrate to a newer upstream version (e.g., via a fresh fork and copy-paste). Project Code Separation : All project-specific code (pipelines, dashboards, scripts) should reside outside the edgar/ directory whenever possible. Upstream Contributions : If we fix a generic bug (like the datetime.date issue), we should consider submitting a PR to the upstream repository, even if we can't pull the changes back immediately. Consequences Pros : Stability: We control our own destiny and avoid breakage from upstream changes. Clarity: We know exactly what we've changed in the core library. Cons : Maintenance Burden: We miss out on upstream improvements unless manually ported. Drift: Over time, our version of edgartools will diverge further from the community standard. Compliance Any PR that modifies files within edgar/ MUST include an entry in docs/DIVERGENCE_LOG.md .","title":"ADR 001: Fork Strategy and Divergence Management"},{"location":"ADR/001_fork_strategy/#adr-001-fork-strategy-and-divergence-management","text":"","title":"ADR 001: Fork Strategy and Divergence Management"},{"location":"ADR/001_fork_strategy/#status","text":"Accepted","title":"Status"},{"location":"ADR/001_fork_strategy/#date","text":"2025-11-30","title":"Date"},{"location":"ADR/001_fork_strategy/#context","text":"This repository is a fork of dgunning/edgartools (version 4.0.0). The upstream repository has advanced significantly (version 4.33.1+) and has a completely unrelated git history, making a standard git merge impossible without catastrophic conflicts (see UPSTREAM_ISSUE.md ). However, we need to maintain and enhance this codebase for our specific use cases (e.g., the dashboard, specific pipeline logic) while occasionally fixing bugs in the core library or cherry-picking critical upstream features.","title":"Context"},{"location":"ADR/001_fork_strategy/#decision","text":"Hard Fork Maintenance : We will treat this repository as a \"hard fork\". We will not attempt to synchronize with upstream via git merge . Divergence Log : We will maintain a docs/DIVERGENCE_LOG.md file to track every modification made to the core edgar/ library code. This allows us to: Distinguish our custom logic from the original library code. Easily identify what changes might need to be re-applied if we ever migrate to a newer upstream version (e.g., via a fresh fork and copy-paste). Project Code Separation : All project-specific code (pipelines, dashboards, scripts) should reside outside the edgar/ directory whenever possible. Upstream Contributions : If we fix a generic bug (like the datetime.date issue), we should consider submitting a PR to the upstream repository, even if we can't pull the changes back immediately.","title":"Decision"},{"location":"ADR/001_fork_strategy/#consequences","text":"Pros : Stability: We control our own destiny and avoid breakage from upstream changes. Clarity: We know exactly what we've changed in the core library. Cons : Maintenance Burden: We miss out on upstream improvements unless manually ported. Drift: Over time, our version of edgartools will diverge further from the community standard.","title":"Consequences"},{"location":"ADR/001_fork_strategy/#compliance","text":"Any PR that modifies files within edgar/ MUST include an entry in docs/DIVERGENCE_LOG.md .","title":"Compliance"},{"location":"examples/chart_generation_README/","text":"XBRL vs XBRL2 Chart Generation This directory contains scripts and documentation for analyzing the XBRL2 rewrite compared to the original XBRL package. Documentation docs/xbrl2-rewrite-analysis.md : Main analysis comparing XBRL vs XBRL2 features and structure docs/xbrl2-complexity-analysis.md : Focused analysis of complexity, method size, and development speed Chart Generation Script The generate_xbrl2_charts.py script creates visualizations for both markdown files. Installation Requirements To generate the charts, you need the following Python packages: pip install matplotlib numpy pandas seaborn Usage Run the script from the project root directory: python generate_xbrl2_charts.py This will generate the following charts in the docs/images/ directory: Basic Comparison Charts: xbrl2-code-metrics.png - Code size and structure metrics xbrl2-code-distribution.png - Distribution of code across files xbrl2-api-functionality.png - API functionality comparison xbrl2-feature-comparison.png - Feature availability comparison xbrl2-code-quality.png - Code quality metrics Complexity Analysis Charts: xbrl2-development-timeline.png - Development speed over time xbrl2-method-complexity.png - Method-level complexity metrics xbrl2-method-size.png - Method size distribution xbrl2-architectural-complexity.png - Architectural design patterns Manual Chart Creation If you're unable to run the script, you can manually create visualizations for the markdown files: Use any visualization tool (Excel, Google Sheets, etc.) to create charts with the data Save the charts in PNG format in docs/images/ with the names listed above The markdown files will automatically display these charts Data Sources The statistics and metrics in this analysis were derived from: Git logs for commit statistics Line counts from wc -l command Code analysis using grep and other Unix tools Manual code analysis for architectural and design patterns","title":"XBRL vs XBRL2 Chart Generation"},{"location":"examples/chart_generation_README/#xbrl-vs-xbrl2-chart-generation","text":"This directory contains scripts and documentation for analyzing the XBRL2 rewrite compared to the original XBRL package.","title":"XBRL vs XBRL2 Chart Generation"},{"location":"examples/chart_generation_README/#documentation","text":"docs/xbrl2-rewrite-analysis.md : Main analysis comparing XBRL vs XBRL2 features and structure docs/xbrl2-complexity-analysis.md : Focused analysis of complexity, method size, and development speed","title":"Documentation"},{"location":"examples/chart_generation_README/#chart-generation-script","text":"The generate_xbrl2_charts.py script creates visualizations for both markdown files.","title":"Chart Generation Script"},{"location":"examples/chart_generation_README/#installation-requirements","text":"To generate the charts, you need the following Python packages: pip install matplotlib numpy pandas seaborn","title":"Installation Requirements"},{"location":"examples/chart_generation_README/#usage","text":"Run the script from the project root directory: python generate_xbrl2_charts.py This will generate the following charts in the docs/images/ directory: Basic Comparison Charts: xbrl2-code-metrics.png - Code size and structure metrics xbrl2-code-distribution.png - Distribution of code across files xbrl2-api-functionality.png - API functionality comparison xbrl2-feature-comparison.png - Feature availability comparison xbrl2-code-quality.png - Code quality metrics Complexity Analysis Charts: xbrl2-development-timeline.png - Development speed over time xbrl2-method-complexity.png - Method-level complexity metrics xbrl2-method-size.png - Method size distribution xbrl2-architectural-complexity.png - Architectural design patterns","title":"Usage"},{"location":"examples/chart_generation_README/#manual-chart-creation","text":"If you're unable to run the script, you can manually create visualizations for the markdown files: Use any visualization tool (Excel, Google Sheets, etc.) to create charts with the data Save the charts in PNG format in docs/images/ with the names listed above The markdown files will automatically display these charts","title":"Manual Chart Creation"},{"location":"examples/chart_generation_README/#data-sources","text":"The statistics and metrics in this analysis were derived from: Git logs for commit statistics Line counts from wc -l command Code analysis using grep and other Unix tools Manual code analysis for architectural and design patterns","title":"Data Sources"},{"location":"examples/user_journeys/","text":"User Journeys: Solve Real Problems with EdgarTools This document showcases common workflows and tasks that financial professionals, developers, and researchers can accomplish using EdgarTools. Each journey addresses a specific problem and provides a concise code example. 1. Company Financial Analysis - Analyze a company's financial health across multiple periods **Problem:** Need to analyze a company's financial health across multiple periods. from edgar import find # Get Microsoft's financial data for the last 3 years company = find(\"MSFT\") financials = company.financials() # Compare key metrics across years revenue = financials.extract(\"Revenues\") net_income = financials.extract(\"NetIncomeLoss\") # Create a financial dashboard import matplotlib.pyplot as plt fig, ax = plt.subplots(figsize=(10, 6)) revenue.plot(kind='bar', ax=ax, position=1, width=0.3, color='blue', alpha=0.7) net_income.plot(kind='bar', ax=ax, position=0, width=0.3, color='green', alpha=0.7) ax.set_title('Microsoft Financial Performance') ax.legend(['Revenue', 'Net Income']) ax.set_ylabel('USD (millions)') plt.xticks(rotation=45) plt.tight_layout() plt.show() 2. Investment Fund Research - Analyze fund holdings and compare share classes **Problem:** Need to analyze fund holdings and compare share classes. from edgar import find # Find a fund by ticker fund = find(\"VFIAX\") # Vanguard 500 Index Fund # Get the fund's structure classes = fund.get_classes() print(f\"Fund has {len(classes)} share classes\") # Get the latest portfolio holdings portfolio = fund.get_portfolio() # Show top 10 holdings by value top_holdings = portfolio.sort_values('value', ascending=False).head(10) top_holdings 3. Insider Trading Analysis - Monitor insider transactions for investment signals **Problem:** Monitor insider transactions for investment signals. from edgar import find, get_insider_transaction_filings # Get recent insider transactions for Tesla company = find(\"TSLA\") insider_filings = company.get_filings(form=[3, 4, 5], limit=20) # Extract and analyze the transactions transactions = [] for filing in insider_filings: form = obj(filing) if hasattr(form, 'transactions') and form.transactions is not None: for t in form.transactions: transactions.append({ 'date': t.transaction_date, 'name': form.reporting_owner.name, 'title': form.reporting_owner.title or 'Unknown', 'type': t.transaction_code, 'shares': t.shares, 'price': t.price_per_share, 'value': t.shares * t.price_per_share if t.price_per_share else None }) # Convert to DataFrame and analyze import pandas as pd tx_df = pd.DataFrame(transactions) # Summarize by transaction type tx_df.groupby('type').agg({ 'shares': 'sum', 'value': 'sum' }).sort_values('value', ascending=False) 4. SEC Filing Discovery - Find specific types of filings across companies or time periods **Problem:** Find specific types of filings across companies or time periods. from edgar import get_filings # Get all 8-K filings (material events) from the last week recent_8ks = get_filings(form=\"8-K\", limit=50) # Filter to find filings mentioning \"acquisition\" acquisition_filings = [] for filing in recent_8ks: text = filing.text() if text and \"acquisition\" in text.lower(): acquisition_filings.append({ 'company': filing.company_name, 'date': filing.filing_date, 'accession_no': filing.accession_no, 'items': filing.items if hasattr(filing, 'items') else None }) # Convert to DataFrame import pandas as pd pd.DataFrame(acquisition_filings) 5. Financial Data Extraction - Extract structured financial data for analysis or modeling **Problem:** Extract structured financial data for analysis or modeling. from edgar import find, obj # Get the latest 10-Q for Amazon company = find(\"AMZN\") latest_10q = company.get_filings(form=\"10-Q\")[0] tenq = obj(latest_10q) # Extract all financial statements balance_sheet = tenq.financials.balance_sheet income_statement = tenq.financials.income_statement cash_flow = tenq.financials.cash_flow # Calculate key financial ratios current_ratio = balance_sheet.loc['AssetsCurrent'] / balance_sheet.loc['LiabilitiesCurrent'] debt_to_equity = balance_sheet.loc['Liabilities'] / balance_sheet.loc['StockholdersEquity'] net_margin = income_statement.loc['NetIncomeLoss'] / income_statement.loc['Revenues'] print(f\"Current Ratio: {current_ratio.iloc[0]:.2f}\") print(f\"Debt-to-Equity: {debt_to_equity.iloc[0]:.2f}\") print(f\"Net Margin: {net_margin.iloc[0]:.2%}\") 6. Fund Holdings Analysis - Analyze what stocks funds are holding and track changes **Problem:** Analyze what stocks funds are holding and track changes. from edgar import find # Find a major investment manager blackrock = find(\"BLK\") # Get their recent 13F filings filings_13f = blackrock.get_filings(form=\"13F-HR\", limit=2) # Extract holdings from the two most recent quarters current_quarter = obj(filings_13f[0]) previous_quarter = obj(filings_13f[1]) # Compare holdings between quarters current_holdings = current_quarter.holdings previous_holdings = previous_quarter.holdings # Merge to compare import pandas as pd merged = pd.merge(current_holdings, previous_holdings, on='nameOfIssuer', suffixes=('_current', '_previous')) # Calculate changes merged['value_change'] = merged['value_current'] - merged['value_previous'] merged['value_change_pct'] = (merged['value_change'] / merged['value_previous']) * 100 # Show biggest position increases merged.sort_values('value_change', ascending=False).head(10) 7. Regulatory Filing Monitoring - Stay updated on new filings from watched companies **Problem:** Stay updated on new filings from watched companies. from edgar import find, get_current_filings # Define a watchlist of companies watchlist = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META'] watchlist_ciks = [find(ticker).cik for ticker in watchlist] # Get today's filings today_filings = get_current_filings() # Filter to only show filings from companies on our watchlist watchlist_filings = today_filings[today_filings.cik.isin(watchlist_ciks)] # Display the filings watchlist_filings[['company_name', 'form', 'filing_date', 'html_link']] 8. AI/LLM Integration - Clean, structured text from SEC filings for AI analysis or LLM processing **Problem:** Need clean, structured text from SEC filings for AI analysis or LLM processing. from edgar import find # Get a 10-K filing company = find(\"NVDA\") # NVIDIA filing = company.get_filings(form=\"10-K\")[0] # Extract clean, readable text (not raw HTML) clean_text = filing.text() # View the formatted text in a notebook or terminal filing.view() # Extract specific sections for targeted analysis risk_factors = filing.get_section(\"Item 1A\", \"Risk Factors\") # Chunk text for LLM context windows chunks = filing.chunk_text(chunk_size=4000, overlap=200) # Process with your favorite LLM library from langchain.llms import OpenAI llm = OpenAI() for i, chunk in enumerate(chunks[:3]): # Process first 3 chunks as example print(f\"Analysis of chunk {i+1}: \") response = llm.generate([f\"Summarize the key points in this SEC filing text: {chunk}\"]) print(response.generations[0][0].text) print(\"\\n---\\n\")","title":"User Journeys: Solve Real Problems with EdgarTools"},{"location":"examples/user_journeys/#user-journeys-solve-real-problems-with-edgartools","text":"This document showcases common workflows and tasks that financial professionals, developers, and researchers can accomplish using EdgarTools. Each journey addresses a specific problem and provides a concise code example.","title":"User Journeys: Solve Real Problems with EdgarTools"},{"location":"xbrl-development/xbrl-parser-design/","text":"High-Level Design for XBRL Parser for SEC Filings 1. System Architecture Overview \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 XBRL File \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 XBRL Parser \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Data Model \u2502 \u2502 Collection \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Statement \u2502 \u2502 Generator \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 2. XBRL File Parser Component 2.1 Parse Instance Document Parse XML Structure : Use an XML parser to read the XBRL instance file Extract Entity Information : Company identifier, reporting period, etc. Extract Contexts : Map context IDs to their associated entity, period, and scenario/segment information Create a lookup table for period contexts (e.g., \"2023-12-31\", \"2023-01-01 to 2023-12-31\") Extract Facts : Each fact includes value, unit, decimals, context reference, and element reference Store facts in a collection mapped by element ID and context Extract Units : Create mapping of unit IDs to their actual units (USD, shares, etc.) Extract Footnotes : If present, extract and map them to facts 2.2 Parse Taxonomy Schema (.xsd) Parse Element Declarations : Extract element IDs, names, data types (monetary, string, etc.) Identify period types (instant or duration) Identify balance types (debit or credit) Identify abstract elements (cannot contain values) Map Namespaces : Create namespace mappings for resolving element references 2.3 Parse Presentation Linkbase Create Hierarchical Structure : Parse parent-child relationships Maintain ordering information (order attribute) Group by extended link roles (ELRs) which define statement sections Capture Preferred Labels : Identify special label roles for presentation Build Presentation Tree : Create a tree structure for each statement/disclosure 2.4 Parse Label Linkbase Map Elements to Labels : Standard labels (default display) Period start/end labels Total labels Negated labels Terse labels Documentation labels (definitions) Handle Multiple Languages : Support labels in different languages if present 2.5 Parse Calculation Linkbase Extract Calculation Relationships : Parent-child calculation hierarchies Weights (+1/-1) for addition/subtraction Group by extended link roles Build Calculation Trees : Create calculation trees for validation and display 2.6 Parse Definition Linkbase Parse Dimensional Relationships : Hypercubes (tables) Dimensions (axes) Domains and domain members Default members Build Dimensional Structure : Create dimensional structure for complex tables 3. Data Model Construction 3.1 Core Data Structures Element Catalog : { \"elementId\": { \"name\": string, \"dataType\": string, \"periodType\": \"instant\"|\"duration\", \"balance\": \"debit\"|\"credit\"|null, \"abstract\": boolean, \"labels\": { \"standard\": string, \"periodStart\": string, \"periodEnd\": string, \"negated\": string, \"documentation\": string, ... } } } Context Registry : { \"contextId\": { \"entity\": { \"identifier\": string, \"scheme\": string }, \"period\": { \"type\": \"instant\"|\"duration\", \"instant\": date|null, \"startDate\": date|null, \"endDate\": date|null }, \"dimensions\": { \"dimensionName\": \"memberName\", ... } } } Fact Database : { \"elementId_contextId\": { \"value\": string, \"decimals\": number|\"INF\", \"unitRef\": string, \"footnotes\": [string] } } 3.2 Relationship Structures Presentation Hierarchy : { \"roleUri\": { \"title\": string, \"root\": { \"elementId\": string, \"children\": [ { \"elementId\": string, \"preferredLabel\": string, \"order\": number, \"children\": [...] } ] } } } Calculation Network : { \"roleUri\": { \"title\": string, \"calculations\": [ { \"parent\": \"elementId\", \"children\": [ { \"elementId\": string, \"weight\": 1|-1, \"order\": number } ] } ] } } Dimensional Structure : { \"roleUri\": { \"tables\": [ { \"tableId\": string, \"axes\": [ { \"axisId\": string, \"domain\": string, \"members\": [string], \"defaultMember\": string } ], \"lineItems\": [string] } ] } } 4. Statement Construction Process 4.1 Identify Statement Structure Locate Appropriate Presentation Network : Find presentation role URIs that correspond to desired statement For example: \"http://xbrl.abc.com/role/StatementOfFinancialPosition\" for balance sheet 4.2 Select Time Period Identify Relevant Contexts : For balance sheet: find contexts with instant periods for desired dates For income statement: find contexts with duration periods for desired date ranges 4.3 Traverse Presentation Hierarchy Walk the Presentation Tree : Start at the root element of the relevant presentation network Process each element in the tree according to its presentation order Handle abstract elements as headers/sections Apply preferred labels (e.g., negated, period start/end, total) 4.4 Retrieve Facts for Elements Map Elements to Facts : For each non-abstract element in the presentation hierarchy Lookup facts using element ID and relevant context ID Apply appropriate unit and decimal formatting 4.5 Apply Dimensional Filters Handle Dimension-Qualified Facts : For tables with dimensions (axes and members) Filter facts by dimensional qualifiers Group related dimensional facts for display 4.6 Format Statement Apply Styling and Indentation : Use presentation hierarchy to determine indentation levels Format numeric values based on decimals attribute Apply appropriate signage (based on balance type and negated labels) Add totals and subtotals as indicated by calculation relationships 5. Specific Example: Reconstructing a Balance Sheet 5.1 Identify Balance Sheet Network Find presentation linkbase role that represents balance sheet Example: \"http://xbrl.abc.com/role/BalanceSheet\" 5.2 Select Contexts for Desired Dates Filter contexts to find those with: Period type = \"instant\" Period end date = desired reporting date (e.g., \"2023-12-31\") No dimension qualifiers (for base statement) 5.3 Build Statement Structure Statement of Financial Position \u2502 \u251c\u2500\u2500 Assets [Abstract] \u2502 \u251c\u2500\u2500 Current Assets [Abstract] \u2502 \u2502 \u251c\u2500\u2500 Cash and Cash Equivalents \u2502 \u2502 \u251c\u2500\u2500 Accounts Receivable, Net \u2502 \u2502 \u251c\u2500\u2500 Inventory, Net \u2502 \u2502 \u2514\u2500\u2500 Total Current Assets \u2502 \u2502 \u2502 \u251c\u2500\u2500 Non-current Assets [Abstract] \u2502 \u2502 \u251c\u2500\u2500 Property, Plant and Equipment, Net \u2502 \u2502 \u251c\u2500\u2500 Goodwill \u2502 \u2502 \u2514\u2500\u2500 Total Non-current Assets \u2502 \u2502 \u2502 \u2514\u2500\u2500 Total Assets \u2502 \u2514\u2500\u2500 Liabilities and Stockholders' Equity [Abstract] \u251c\u2500\u2500 Liabilities [Abstract] \u2502 \u251c\u2500\u2500 Current Liabilities [Abstract] \u2502 \u2502 \u251c\u2500\u2500 Accounts Payable \u2502 \u2502 \u251c\u2500\u2500 Short-term Debt \u2502 \u2502 \u2514\u2500\u2500 Total Current Liabilities \u2502 \u2502 \u2502 \u251c\u2500\u2500 Non-current Liabilities [Abstract] \u2502 \u2502 \u251c\u2500\u2500 Long-term Debt \u2502 \u2502 \u251c\u2500\u2500 Deferred Tax Liabilities \u2502 \u2502 \u2514\u2500\u2500 Total Non-current Liabilities \u2502 \u2502 \u2502 \u2514\u2500\u2500 Total Liabilities \u2502 \u251c\u2500\u2500 Stockholders' Equity [Abstract] \u2502 \u251c\u2500\u2500 Common Stock \u2502 \u251c\u2500\u2500 Additional Paid-in Capital \u2502 \u251c\u2500\u2500 Retained Earnings \u2502 \u2514\u2500\u2500 Total Stockholders' Equity \u2502 \u2514\u2500\u2500 Total Liabilities and Stockholders' Equity 5.4 Populate Statement with Facts For each non-abstract element in the hierarchy: Look up element in Element Catalog to get its properties Find the fact in the Fact Database using element ID and context ID Format value using unit and decimals information Apply appropriate sign based on element's balance type 5.5 Validate Totals Using Calculation Relationships Use calculation relationships to check that totals match their components Highlight any calculation inconsistencies 5.6 Generate Final Statement Output formatted balance sheet with: Proper hierarchy/indentation Correctly formatted values Column(s) for each period Appropriate signage Computed subtotals and totals","title":"High-Level Design for XBRL Parser for SEC Filings"},{"location":"xbrl-development/xbrl-parser-design/#high-level-design-for-xbrl-parser-for-sec-filings","text":"","title":"High-Level Design for XBRL Parser for SEC Filings"},{"location":"xbrl-development/xbrl-parser-design/#1-system-architecture-overview","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 XBRL File \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 XBRL Parser \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Data Model \u2502 \u2502 Collection \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Statement \u2502 \u2502 Generator \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"1. System Architecture Overview"},{"location":"xbrl-development/xbrl-parser-design/#2-xbrl-file-parser-component","text":"","title":"2. XBRL File Parser Component"},{"location":"xbrl-development/xbrl-parser-design/#21-parse-instance-document","text":"Parse XML Structure : Use an XML parser to read the XBRL instance file Extract Entity Information : Company identifier, reporting period, etc. Extract Contexts : Map context IDs to their associated entity, period, and scenario/segment information Create a lookup table for period contexts (e.g., \"2023-12-31\", \"2023-01-01 to 2023-12-31\") Extract Facts : Each fact includes value, unit, decimals, context reference, and element reference Store facts in a collection mapped by element ID and context Extract Units : Create mapping of unit IDs to their actual units (USD, shares, etc.) Extract Footnotes : If present, extract and map them to facts","title":"2.1 Parse Instance Document"},{"location":"xbrl-development/xbrl-parser-design/#22-parse-taxonomy-schema-xsd","text":"Parse Element Declarations : Extract element IDs, names, data types (monetary, string, etc.) Identify period types (instant or duration) Identify balance types (debit or credit) Identify abstract elements (cannot contain values) Map Namespaces : Create namespace mappings for resolving element references","title":"2.2 Parse Taxonomy Schema (.xsd)"},{"location":"xbrl-development/xbrl-parser-design/#23-parse-presentation-linkbase","text":"Create Hierarchical Structure : Parse parent-child relationships Maintain ordering information (order attribute) Group by extended link roles (ELRs) which define statement sections Capture Preferred Labels : Identify special label roles for presentation Build Presentation Tree : Create a tree structure for each statement/disclosure","title":"2.3 Parse Presentation Linkbase"},{"location":"xbrl-development/xbrl-parser-design/#24-parse-label-linkbase","text":"Map Elements to Labels : Standard labels (default display) Period start/end labels Total labels Negated labels Terse labels Documentation labels (definitions) Handle Multiple Languages : Support labels in different languages if present","title":"2.4 Parse Label Linkbase"},{"location":"xbrl-development/xbrl-parser-design/#25-parse-calculation-linkbase","text":"Extract Calculation Relationships : Parent-child calculation hierarchies Weights (+1/-1) for addition/subtraction Group by extended link roles Build Calculation Trees : Create calculation trees for validation and display","title":"2.5 Parse Calculation Linkbase"},{"location":"xbrl-development/xbrl-parser-design/#26-parse-definition-linkbase","text":"Parse Dimensional Relationships : Hypercubes (tables) Dimensions (axes) Domains and domain members Default members Build Dimensional Structure : Create dimensional structure for complex tables","title":"2.6 Parse Definition Linkbase"},{"location":"xbrl-development/xbrl-parser-design/#3-data-model-construction","text":"","title":"3. Data Model Construction"},{"location":"xbrl-development/xbrl-parser-design/#31-core-data-structures","text":"Element Catalog : { \"elementId\": { \"name\": string, \"dataType\": string, \"periodType\": \"instant\"|\"duration\", \"balance\": \"debit\"|\"credit\"|null, \"abstract\": boolean, \"labels\": { \"standard\": string, \"periodStart\": string, \"periodEnd\": string, \"negated\": string, \"documentation\": string, ... } } } Context Registry : { \"contextId\": { \"entity\": { \"identifier\": string, \"scheme\": string }, \"period\": { \"type\": \"instant\"|\"duration\", \"instant\": date|null, \"startDate\": date|null, \"endDate\": date|null }, \"dimensions\": { \"dimensionName\": \"memberName\", ... } } } Fact Database : { \"elementId_contextId\": { \"value\": string, \"decimals\": number|\"INF\", \"unitRef\": string, \"footnotes\": [string] } }","title":"3.1 Core Data Structures"},{"location":"xbrl-development/xbrl-parser-design/#32-relationship-structures","text":"Presentation Hierarchy : { \"roleUri\": { \"title\": string, \"root\": { \"elementId\": string, \"children\": [ { \"elementId\": string, \"preferredLabel\": string, \"order\": number, \"children\": [...] } ] } } } Calculation Network : { \"roleUri\": { \"title\": string, \"calculations\": [ { \"parent\": \"elementId\", \"children\": [ { \"elementId\": string, \"weight\": 1|-1, \"order\": number } ] } ] } } Dimensional Structure : { \"roleUri\": { \"tables\": [ { \"tableId\": string, \"axes\": [ { \"axisId\": string, \"domain\": string, \"members\": [string], \"defaultMember\": string } ], \"lineItems\": [string] } ] } }","title":"3.2 Relationship Structures"},{"location":"xbrl-development/xbrl-parser-design/#4-statement-construction-process","text":"","title":"4. Statement Construction Process"},{"location":"xbrl-development/xbrl-parser-design/#41-identify-statement-structure","text":"Locate Appropriate Presentation Network : Find presentation role URIs that correspond to desired statement For example: \"http://xbrl.abc.com/role/StatementOfFinancialPosition\" for balance sheet","title":"4.1 Identify Statement Structure"},{"location":"xbrl-development/xbrl-parser-design/#42-select-time-period","text":"Identify Relevant Contexts : For balance sheet: find contexts with instant periods for desired dates For income statement: find contexts with duration periods for desired date ranges","title":"4.2 Select Time Period"},{"location":"xbrl-development/xbrl-parser-design/#43-traverse-presentation-hierarchy","text":"Walk the Presentation Tree : Start at the root element of the relevant presentation network Process each element in the tree according to its presentation order Handle abstract elements as headers/sections Apply preferred labels (e.g., negated, period start/end, total)","title":"4.3 Traverse Presentation Hierarchy"},{"location":"xbrl-development/xbrl-parser-design/#44-retrieve-facts-for-elements","text":"Map Elements to Facts : For each non-abstract element in the presentation hierarchy Lookup facts using element ID and relevant context ID Apply appropriate unit and decimal formatting","title":"4.4 Retrieve Facts for Elements"},{"location":"xbrl-development/xbrl-parser-design/#45-apply-dimensional-filters","text":"Handle Dimension-Qualified Facts : For tables with dimensions (axes and members) Filter facts by dimensional qualifiers Group related dimensional facts for display","title":"4.5 Apply Dimensional Filters"},{"location":"xbrl-development/xbrl-parser-design/#46-format-statement","text":"Apply Styling and Indentation : Use presentation hierarchy to determine indentation levels Format numeric values based on decimals attribute Apply appropriate signage (based on balance type and negated labels) Add totals and subtotals as indicated by calculation relationships","title":"4.6 Format Statement"},{"location":"xbrl-development/xbrl-parser-design/#5-specific-example-reconstructing-a-balance-sheet","text":"","title":"5. Specific Example: Reconstructing a Balance Sheet"},{"location":"xbrl-development/xbrl-parser-design/#51-identify-balance-sheet-network","text":"Find presentation linkbase role that represents balance sheet Example: \"http://xbrl.abc.com/role/BalanceSheet\"","title":"5.1 Identify Balance Sheet Network"},{"location":"xbrl-development/xbrl-parser-design/#52-select-contexts-for-desired-dates","text":"Filter contexts to find those with: Period type = \"instant\" Period end date = desired reporting date (e.g., \"2023-12-31\") No dimension qualifiers (for base statement)","title":"5.2 Select Contexts for Desired Dates"},{"location":"xbrl-development/xbrl-parser-design/#53-build-statement-structure","text":"Statement of Financial Position \u2502 \u251c\u2500\u2500 Assets [Abstract] \u2502 \u251c\u2500\u2500 Current Assets [Abstract] \u2502 \u2502 \u251c\u2500\u2500 Cash and Cash Equivalents \u2502 \u2502 \u251c\u2500\u2500 Accounts Receivable, Net \u2502 \u2502 \u251c\u2500\u2500 Inventory, Net \u2502 \u2502 \u2514\u2500\u2500 Total Current Assets \u2502 \u2502 \u2502 \u251c\u2500\u2500 Non-current Assets [Abstract] \u2502 \u2502 \u251c\u2500\u2500 Property, Plant and Equipment, Net \u2502 \u2502 \u251c\u2500\u2500 Goodwill \u2502 \u2502 \u2514\u2500\u2500 Total Non-current Assets \u2502 \u2502 \u2502 \u2514\u2500\u2500 Total Assets \u2502 \u2514\u2500\u2500 Liabilities and Stockholders' Equity [Abstract] \u251c\u2500\u2500 Liabilities [Abstract] \u2502 \u251c\u2500\u2500 Current Liabilities [Abstract] \u2502 \u2502 \u251c\u2500\u2500 Accounts Payable \u2502 \u2502 \u251c\u2500\u2500 Short-term Debt \u2502 \u2502 \u2514\u2500\u2500 Total Current Liabilities \u2502 \u2502 \u2502 \u251c\u2500\u2500 Non-current Liabilities [Abstract] \u2502 \u2502 \u251c\u2500\u2500 Long-term Debt \u2502 \u2502 \u251c\u2500\u2500 Deferred Tax Liabilities \u2502 \u2502 \u2514\u2500\u2500 Total Non-current Liabilities \u2502 \u2502 \u2502 \u2514\u2500\u2500 Total Liabilities \u2502 \u251c\u2500\u2500 Stockholders' Equity [Abstract] \u2502 \u251c\u2500\u2500 Common Stock \u2502 \u251c\u2500\u2500 Additional Paid-in Capital \u2502 \u251c\u2500\u2500 Retained Earnings \u2502 \u2514\u2500\u2500 Total Stockholders' Equity \u2502 \u2514\u2500\u2500 Total Liabilities and Stockholders' Equity","title":"5.3 Build Statement Structure"},{"location":"xbrl-development/xbrl-parser-design/#54-populate-statement-with-facts","text":"For each non-abstract element in the hierarchy: Look up element in Element Catalog to get its properties Find the fact in the Fact Database using element ID and context ID Format value using unit and decimals information Apply appropriate sign based on element's balance type","title":"5.4 Populate Statement with Facts"},{"location":"xbrl-development/xbrl-parser-design/#55-validate-totals-using-calculation-relationships","text":"Use calculation relationships to check that totals match their components Highlight any calculation inconsistencies","title":"5.5 Validate Totals Using Calculation Relationships"},{"location":"xbrl-development/xbrl-parser-design/#56-generate-final-statement","text":"Output formatted balance sheet with: Proper hierarchy/indentation Correctly formatted values Column(s) for each period Appropriate signage Computed subtotals and totals","title":"5.6 Generate Final Statement"}]}